<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LoL Stadium — Mobile Duel Arena</title>

  <!-- Tailwind CDN (one file site; no build step) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            ui: ['ui-sans-serif','system-ui','-apple-system','Segoe UI','Roboto','Ubuntu','Cantarell','Noto Sans','Helvetica Neue','Arial','"Apple Color Emoji"','"Segoe UI Emoji"'],
          },
          boxShadow: {
            glow: '0 0 0 3px rgb(59 130 246 / 0.25), 0 10px 25px rgb(0 0 0 / 0.25)',
          },
          keyframes: {
            hit: { '0%': { transform:'translateX(0)' }, '20%': { transform:'translateX(-6px)' }, '40%': { transform:'translateX(6px)' }, '60%': { transform:'translateX(-3px)' }, '80%': { transform:'translateX(3px)' }, '100%': { transform:'translateX(0)' } },
            pulsebar: { '0%': { width:'100%' }, '100%': { width:'0%' } }
          },
          animation: {
            hit: 'hit 300ms ease-in-out',
          }
        }
      }
    }
  </script>

  <style>
    /* Minimal custom helpers (kept inside the single file) */
    .line-clamp-2{display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}
    .tap-highlight-none{-webkit-tap-highlight-color:transparent}
  </style>
</head>
<body class="bg-slate-950 text-slate-100 font-ui antialiased">
  <!-- Header -->
  <header class="sticky top-0 z-50 backdrop-blur bg-slate-950/70 border-b border-white/10">
    <div class="mx-auto max-w-6xl px-4 py-3 flex items-center gap-3">
      <div class="size-8 rounded-md bg-indigo-500/20 grid place-items-center">
        <svg xmlns="http://www.w3.org/2000/svg" class="size-5" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3 6 6 .9-4.5 4.3L17.8 20 12 16.9 6.2 20l1.3-6.8L3 8.9 9 8z"/></svg>
      </div>
      <div class="flex-1">
        <h1 class="text-lg font-semibold leading-tight">LoL Stadium</h1>
        <p class="text-xs text-slate-400">Pick two champions • Tap abilities (Q/W/E/R) • Simple cooldowns • First to zero loses</p>
      </div>
      <button id="randomFightBtn" class="tap-highlight-none rounded-lg px-3 py-2 text-sm font-medium bg-indigo-600 hover:bg-indigo-500 active:scale-[.98] transition focus:outline-none focus:ring-2 focus:ring-indigo-400">Random Duel</button>
    </div>
  </header>

  <!-- App -->
  <main class="mx-auto max-w-6xl px-4 py-4 md:py-8">
    <!-- Controls -->
    <section class="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6">
      <!-- Left picker -->
      <div class="rounded-xl border border-white/10 bg-gradient-to-b from-slate-900 to-slate-950 p-3 md:p-4">
        <div class="flex items-center gap-2">
          <div class="grow">
            <label for="leftSearch" class="sr-only">Left champion</label>
            <input id="leftSearch" class="w-full rounded-lg bg-slate-900/70 border border-white/10 px-3 py-2 text-sm placeholder:text-slate-500 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Search left champion…" list="championsList" autocomplete="off">
          </div>
          <button id="leftPickRandom" class="tap-highlight-none rounded-md px-3 py-2 text-xs bg-white/10 hover:bg-white/15">Random</button>
        </div>
        <datalist id="championsList"></datalist>
        <div id="leftCard" class="mt-3"></div>
      </div>

      <!-- Right picker -->
      <div class="rounded-xl border border-white/10 bg-gradient-to-b from-slate-900 to-slate-950 p-3 md:p-4">
        <div class="flex items-center gap-2">
          <div class="grow">
            <label for="rightSearch" class="sr-only">Right champion</label>
            <input id="rightSearch" class="w-full rounded-lg bg-slate-900/70 border border-white/10 px-3 py-2 text-sm placeholder:text-slate-500 focus:outline-none focus:ring-2 focus:ring-rose-500" placeholder="Search right champion…" list="championsList" autocomplete="off">
          </div>
          <button id="rightPickRandom" class="tap-highlight-none rounded-md px-3 py-2 text-xs bg-white/10 hover:bg-white/15">Random</button>
        </div>
        <div id="rightCard" class="mt-3"></div>
      </div>
    </section>

    <!-- Arena -->
    <section class="mt-4 md:mt-8 rounded-2xl border border-white/10 overflow-hidden">
      <div id="arenaBackdrop" class="relative bg-slate-900">
        <div class="absolute inset-0 bg-[radial-gradient(ellipse_at_center,_rgba(20,20,30,0.6),_rgba(2,6,23,0.95))] backdrop-blur-sm"></div>
        <div class="relative grid grid-cols-1 md:grid-cols-2 gap-3 md:gap-8 p-3 md:p-6">
          <!-- Left fighter panel -->
          <div id="leftFighter" class="rounded-xl bg-white/5 border border-white/10 overflow-hidden">
            <div class="p-3 flex items-center gap-3">
              <img id="leftIcon" alt="" class="size-12 rounded-lg ring-1 ring-white/10 object-cover" />
              <div class="min-w-0">
                <div class="flex items-center gap-2">
                  <h3 id="leftName" class="font-semibold truncate">—</h3>
                  <span id="leftTags" class="text-[10px] px-1.5 py-0.5 rounded bg-white/10"></span>
                </div>
                <div class="mt-1 h-2 w-full bg-slate-800 rounded overflow-hidden">
                  <div id="leftHpBar" class="h-full bg-green-500 transition-all"></div>
                </div>
                <div class="mt-1 text-[11px] text-slate-300"><span id="leftHpText">HP —/—</span></div>
              </div>
            </div>
            <div class="px-2 pb-3 grid grid-cols-4 gap-2" id="leftAbilities"></div>
          </div>

          <!-- Right fighter panel -->
          <div id="rightFighter" class="rounded-xl bg-white/5 border border-white/10 overflow-hidden">
            <div class="p-3 flex items-center gap-3">
              <img id="rightIcon" alt="" class="size-12 rounded-lg ring-1 ring-white/10 object-cover" />
              <div class="min-w-0">
                <div class="flex items-center gap-2">
                  <h3 id="rightName" class="font-semibold truncate">—</h3>
                  <span id="rightTags" class="text-[10px] px-1.5 py-0.5 rounded bg-white/10"></span>
                </div>
                <div class="mt-1 h-2 w-full bg-slate-800 rounded overflow-hidden">
                  <div id="rightHpBar" class="h-full bg-green-500 transition-all"></div>
                </div>
                <div class="mt-1 text-[11px] text-slate-300"><span id="rightHpText">HP —/—</span></div>
              </div>
            </div>
            <div class="px-2 pb-3 grid grid-cols-4 gap-2" id="rightAbilities"></div>
          </div>
        </div>
      </div>

      <!-- Controls / Log -->
      <div class="bg-slate-900/80 border-t border-white/10">
        <div class="p-3 md:p-4 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
          <div class="flex items-center gap-2">
            <button id="resetBtn" class="tap-highlight-none rounded-lg px-3 py-2 text-sm bg-white/10 hover:bg-white/15">Reset</button>
            <button id="swapBtn" class="tap-highlight-none rounded-lg px-3 py-2 text-sm bg-white/10 hover:bg-white/15">Swap Sides</button>
            <label class="ml-1 inline-flex items-center gap-2 text-sm">
              <input id="autoPlayToggle" type="checkbox" class="size-4 accent-indigo-500">
              Auto‑play
            </label>
          </div>
          <div id="turnBadge" class="text-xs px-2 py-1 rounded bg-indigo-600">Turn: —</div>
        </div>
        <div id="log" class="px-3 md:px-4 pb-4 space-y-2 max-h-56 overflow-auto text-sm"></div>
      </div>
    </section>

    <!-- Footer / Attribution -->
    <footer class="mt-6 text-xs text-slate-400">
      <p>Champions, names, images, and ability info are pulled live from Riot’s Data Dragon. League of Legends and Riot Games are trademarks or registered trademarks of Riot Games, Inc. This is a fan‑made demo for educational purposes.</p>
    </footer>
  </main>

  <script>
  ;(() => {
    const $ = (sel, el=document) => el.querySelector(sel);
    const $$ = (sel, el=document) => [...el.querySelectorAll(sel)];

    // --- Globals / State ---
    const state = {
      version: null,
      champions: {},       // keyed by champion id (e.g., "Ahri")
      champArray: [],      // [{id, name, ...}]
      left: null,          // full champion details
      right: null,
      leftHP: 0,
      rightHP: 0,
      leftHPMax: 0,
      rightHPMax: 0,
      leftCD: [0,0,0,0],
      rightCD: [0,0,0,0],
      turn: null,          // "left" | "right"
      autoPlay: false,
      autoplayTimer: null,
    };

    const els = {
      list: $('#championsList'),
      leftSearch: $('#leftSearch'),
      rightSearch: $('#rightSearch'),
      leftCard: $('#leftCard'),
      rightCard: $('#rightCard'),
      leftIcon: $('#leftIcon'),
      rightIcon: $('#rightIcon'),
      leftName: $('#leftName'),
      rightName: $('#rightName'),
      leftTags: $('#leftTags'),
      rightTags: $('#rightTags'),
      leftHpBar: $('#leftHpBar'),
      rightHpBar: $('#rightHpBar'),
      leftHpText: $('#leftHpText'),
      rightHpText: $('#rightHpText'),
      leftAbilities: $('#leftAbilities'),
      rightAbilities: $('#rightAbilities'),
      turnBadge: $('#turnBadge'),
      log: $('#log'),
      arenaBackdrop: $('#arenaBackdrop'),
      randomFightBtn: $('#randomFightBtn'),
      leftPickRandom: $('#leftPickRandom'),
      rightPickRandom: $('#rightPickRandom'),
      resetBtn: $('#resetBtn'),
      swapBtn: $('#swapBtn'),
      autoPlayToggle: $('#autoPlayToggle'),
    };

    // --- Data Dragon helpers ---
    const DDRAGON_VERSIONS = 'https://ddragon.leagueoflegends.com/api/versions.json'; // latest is [0]
    const ddragonData = (version, path) => `https://ddragon.leagueoflegends.com/cdn/${version}/data/en_US/${path}`;
    const ddragonImgChampion = (version, file) => `https://ddragon.leagueoflegends.com/cdn/${version}/img/champion/${file}`;
    const ddragonSplash = (champId, skinIndex=0) => `https://ddragon.leagueoflegends.com/cdn/img/champion/splash/${champId}_${skinIndex}.jpg`;

    async function getJSON(url){
      const res = await fetch(url, { cache: 'no-store' });
      if(!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return res.json();
    }

    async function bootstrap(){
      try {
        // 1) Latest version
        const versions = await getJSON(DDRAGON_VERSIONS);
        state.version = versions[0]; // latest
        // 2) Short champions list
        const champShort = await getJSON(ddragonData(state.version, 'champion.json'));
        state.champions = champShort.data;
        state.champArray = Object.values(state.champions).sort((a,b) => a.name.localeCompare(b.name));

        // Fill datalist
        els.list.innerHTML = state.champArray.map(c => `<option value="${c.name}" data-id="${c.id}"></option>`).join('');

        // Prefill two random champs
        pickRandom('left'); pickRandom('right');

        logLine(`Loaded Data Dragon ${state.version}.`);
      } catch (err) {
        console.error(err);
        logLine('Failed to load Data Dragon. Check your network or try again later.');
      }
    }

    function findChampionIdByName(name){
      const found = state.champArray.find(c => c.name.toLowerCase() === String(name||'').toLowerCase());
      return found?.id || null;
    }

    async function loadChampionFull(id){
      const url = ddragonData(state.version, `champion/${id}.json`);
      const raw = await getJSON(url);
      // structure: { data: { [id]: { ... champion } } }
      return raw.data[id];
    }

    // --- UI Renderers ---
    function renderChampionSide(side){
      const champ = state[side];
      if(!champ) return;
      const prefix = side === 'left' ? 'left' : 'right';

      // Icon + name + tags
      const iconUrl = ddragonImgChampion(state.version, champ.image.full);
      const tags = (champ.tags || []).join(' / ') || '—';

      (side==='left' ? els.leftIcon : els.rightIcon).src = iconUrl;
      (side==='left' ? els.leftName : els.rightName).textContent = champ.name;
      (side==='left' ? els.leftTags : els.rightTags).textContent = tags;

      // HP
      const hp = side==='left' ? state.leftHP : state.rightHP;
      const hpMax = side==='left' ? state.leftHPMax : state.rightHPMax;
      const hpPct = hpMax ? Math.max(0, Math.min(100, (hp / hpMax) * 100)) : 0;

      const bar = side==='left' ? els.leftHpBar : els.rightHpBar;
      bar.style.width = hpPct + '%';
      bar.className = 'h-full transition-all ' + (hpPct>50 ? 'bg-green-500' : hpPct>20 ? 'bg-yellow-400' : 'bg-rose-500');
      (side==='left' ? els.leftHpText : els.rightHpText).textContent = `HP ${Math.max(0, Math.round(hp))} / ${Math.round(hpMax)}`;

      // Abilities
      const container = side==='left' ? els.leftAbilities : els.rightAbilities;
      container.innerHTML = '';

      (champ.spells || []).slice(0,4).forEach((sp, idx) => {
        const cdLeft = (side==='left' ? state.leftCD[idx] : state.rightCD[idx]) || 0;
        const disabled = cdLeft > 0 || winner();
        const label = ['Q','W','E','R'][idx] || '?';
        const cdText = cdLeft > 0 ? `<div class="absolute inset-0 bg-black/60 grid place-items-center text-sm font-semibold">${cdLeft}</div>` : '';
        const tip = [
          `${label}: ${sp.name}`,
          (sp.cooldownBurn ? `CD: ${sp.cooldownBurn}` : null),
          (sp.costBurn && sp.resource ? `Cost: ${sp.costBurn} ${champ.partype}` : null),
        ].filter(Boolean).join(' • ');

        const btn = document.createElement('button');
        btn.className = `relative group rounded-lg border border-white/10 bg-white/5 hover:bg-white/10 focus:outline-none focus:ring-2 ${side==='left' ? 'focus:ring-indigo-500' : 'focus:ring-rose-500'} overflow-hidden`;
        btn.title = tip;
        btn.disabled = disabled;
        btn.dataset.side = side;
        btn.dataset.idx = idx;

        btn.innerHTML = `
          <div class="aspect-square grid place-items-center">
            <img alt="${sp.name}" class="size-14 md:size-16 object-cover" src="https://ddragon.leagueoflegends.com/cdn/${state.version}/img/spell/${sp.image.full}">
          </div>
          <div class="absolute top-1 left-1 rounded px-1.5 py-0.5 text-[10px] font-semibold ${side==='left' ? 'bg-indigo-600' : 'bg-rose-600'}">${label}</div>
          <div class="absolute bottom-0 inset-x-0 h-1 bg-white/10"><div class="h-full ${cdLeft>0 ? 'animate-[pulsebar_1s_linear_infinite]' : ''} ${side==='left' ? 'bg-indigo-500' : 'bg-rose-500'}"></div></div>
          ${cdText}
        `;
        btn.addEventListener('click', onAbilityClick);
        container.appendChild(btn);
      });

      // Backdrop (first skin splash)
      els.arenaBackdrop.style.backgroundImage = champ ? `url('${ddragonSplash((state.left?.id||'') || champ.id, 0)}')` : '';
      els.arenaBackdrop.style.backgroundSize = 'cover';
      els.arenaBackdrop.style.backgroundPosition = 'center';
    }

    function renderAll(){
      renderChampionSide('left');
      renderChampionSide('right');
      updateTurnBadge();
    }

    function updateTurnBadge(){
      const t = state.turn ? (state.turn==='left' ? 'Left' : 'Right') : '—';
      els.turnBadge.textContent = `Turn: ${t}`;
      els.turnBadge.className = `text-xs px-2 py-1 rounded ${state.turn==='left' ? 'bg-indigo-600' : state.turn==='right' ? 'bg-rose-600' : 'bg-slate-700'}`;
    }

    function logLine(text){
      const row = document.createElement('div');
      row.className = 'rounded-lg border border-white/10 bg-white/5 px-3 py-2';
      row.textContent = text;
      els.log.prepend(row);
      // keep last ~100
      while(els.log.children.length > 100) els.log.removeChild(els.log.lastChild);
    }

    // --- Simple “combat” math (fun, not accurate to LoL) ---
    function baseHP(champ){
      // Approx "level 10" feeling: base + 9 * perLevel
      return (champ.stats.hp || 600) + (champ.stats.hpperlevel || 90) * 9;
    }

    function estimateAbilityPower(spell, champ, idx){
      // Try effectBurn numbers first (e.g., "80/110/140/170/200"), fallback to numbers in tooltip
      let candidates = [];
      if (Array.isArray(spell.effectBurn)){
        spell.effectBurn.forEach(s => {
          if (!s) return;
          String(s).split('/').forEach(x => {
            const v = parseFloat(x);
            if (!isNaN(v)) candidates.push(v);
          });
        });
      }
      if (candidates.length === 0 && typeof spell.tooltip === 'string'){
        const nums = spell.tooltip.match(/\d+(\.\d+)?/g) || [];
        candidates = nums.map(Number);
      }
      // Heuristics
      let base = candidates.length ? median(candidates) : 50;
      if (idx === 3) base *= 1.35; // R hits harder
      // Light scaling by champ offense
      const ad = champ.stats.attackdamage || 60;
      const apish = (champ.tags||[]).includes('Mage') ? 40 : 10;
      base += (ad * 0.15) + apish;
      // Clamp
      return Math.max(30, Math.min(260, Math.round(base)));
    }

    function median(arr){
      const a = [...arr].sort((x,y)=>x-y);
      const mid = Math.floor(a.length/2);
      return a.length % 2 ? a[mid] : (a[mid-1] + a[mid]) / 2;
    }

    function abilityCooldown(spell){
      // use first rank cooldown or fallback 3
      if (Array.isArray(spell.cooldown) && spell.cooldown.length) {
        const v = Math.round(spell.cooldown[0]);
        return isNaN(v) ? 3 : Math.max(1, Math.min(8, v));
      }
      return 3;
    }

    function winner(){
      if (state.leftHP <= 0) return 'right';
      if (state.rightHP <= 0) return 'left';
      return null;
    }

    function endTurn(){
      // decrement CDs
      state.leftCD = state.leftCD.map(c => Math.max(0, c-1));
      state.rightCD = state.rightCD.map(c => Math.max(0, c-1));
      // swap turn
      state.turn = state.turn === 'left' ? 'right' : 'left';
      updateTurnBadge();
      renderAll();
      // autoplay
      if(state.autoPlay && !winner()){
        clearTimeout(state.autoplayTimer);
        state.autoplayTimer = setTimeout(() => {
          autoPickAndFire(state.turn);
        }, 600);
      }
    }

    function onAbilityClick(e){
      const btn = e.currentTarget;
      const side = btn.dataset.side;
      const idx = +btn.dataset.idx;

      if (winner()) return;
      if (state.turn !== side) return; // not your turn

      const me = state[side];
      const themSide = side === 'left' ? 'right' : 'left';
      const them = state[themSide];

      const spell = me.spells[idx];
      const dmg = estimateAbilityPower(spell, me, idx);
      const cd = abilityCooldown(spell);

      // apply
      if (side === 'left') {
        state.rightHP -= dmg;
        state.leftCD[idx] = cd;
        $('#rightFighter').classList.add('animate-hit');
        setTimeout(()=>$('#rightFighter').classList.remove('animate-hit'), 310);
      } else {
        state.leftHP -= dmg;
        state.rightCD[idx] = cd;
        $('#leftFighter').classList.add('animate-hit');
        setTimeout(()=>$('#leftFighter').classList.remove('animate-hit'), 310);
      }

      logLine(`${me.name} used ${['Q','W','E','R'][idx]} — ${spell.name} for ~${dmg} dmg.`);
      renderAll();

      // win check
      const w = winner();
      if (w){
        const champ = state[w];
        logLine(`🏆 ${champ.name} wins!`);
        updateTurnBadge();
        return;
      }
      endTurn();
    }

    function autoPickAndFire(side){
      const champ = state[side];
      const cds = side==='left' ? state.leftCD : state.rightCD;
      const ready = [0,1,2,3].filter(i => cds[i] === 0);
      if(ready.length === 0) { endTurn(); return; }
      // prefer R if ready, else random ability
      const pick = ready.includes(3) ? 3 : ready[Math.floor(Math.random() * ready.length)];
      // simulate a click
      const container = side==='left' ? els.leftAbilities : els.rightAbilities;
      const btn = container.querySelector(`[data-idx="${pick}"]`);
      if(btn && !btn.disabled) btn.click();
      else endTurn();
    }

    // --- Actions / Picks ---
    async function setChampionForSide(side, champId){
      if(!champId) return;
      try {
        const full = await loadChampionFull(champId);
        state[side] = full;
        // (Re)calc HP and reset CDs for that side
        const hpBase = baseHP(full);
        if(side==='left'){ state.leftHPMax = hpBase; state.leftHP = hpBase; state.leftCD = [0,0,0,0]; }
        else { state.rightHPMax = hpBase; state.rightHP = hpBase; state.rightCD = [0,0,0,0]; }
        // first turn random if not set
        if(!state.turn) state.turn = Math.random() > 0.5 ? 'left' : 'right';
        renderAll();
        // Fill the compact info card under the search input
        renderMiniCard(side, full);
      } catch (err) {
        console.error(err);
        logLine(`Failed to load ${champId}. Try another champion.`);
      }
    }

    function renderMiniCard(side, champ){
      const target = side==='left' ? els.leftCard : els.rightCard;
      const roles = (champ.tags||[]).join(' • ');
      target.innerHTML = `
        <div class="mt-3 rounded-lg border border-white/10 bg-white/5 p-3 flex items-center gap-3">
          <img class="size-12 rounded-md object-cover ring-1 ring-white/10" src="${ddragonImgChampion(state.version, champ.image.full)}" alt="">
          <div class="min-w-0">
            <div class="font-medium truncate">${champ.name}</div>
            <div class="text-xs text-slate-400">${roles || '—'}</div>
            <p class="mt-1 text-xs text-slate-300 line-clamp-2">${champ.blurb || ''}</p>
          </div>
        </div>
      `;
    }

    function pickRandom(side){
      const r = state.champArray[Math.floor(Math.random() * state.champArray.length)];
      if (!r) return;
      // write the search field and set
      (side==='left' ? els.leftSearch : els.rightSearch).value = r.name;
      setChampionForSide(side, r.id);
    }

    function swapSides(){
      const L = state.left, R = state.right;
      const Lhp = state.leftHP, Rhp = state.rightHP;
      const Lmax = state.leftHPMax, Rmax = state.rightHPMax;
      const Lcd = [...state.leftCD], Rcd = [...state.rightCD];

      state.left = R; state.right = L;
      state.leftHP = Rhp; state.rightHP = Lhp;
      state.leftHPMax = Rmax; state.rightHPMax = Lmax;
      state.leftCD = Rcd; state.rightCD = Lcd;

      // Flip turn, too
      state.turn = state.turn === 'left' ? 'right' : 'left';
      renderAll();
      renderMiniCard('left', state.left);
      renderMiniCard('right', state.right);
    }

    function hardReset(){
      if(state.left){ state.leftHP = state.leftHPMax = baseHP(state.left); state.leftCD=[0,0,0,0]; }
      if(state.right){ state.rightHP = state.rightHPMax = baseHP(state.right); state.rightCD=[0,0,0,0]; }
      state.turn = Math.random() > 0.5 ? 'left' : 'right';
      renderAll();
      logLine('Match reset.');
    }

    // --- Wire up events ---
    els.leftSearch.addEventListener('change', () => {
      const id = findChampionIdByName(els.leftSearch.value);
      if (id) setChampionForSide('left', id);
    });
    els.rightSearch.addEventListener('change', () => {
      const id = findChampionIdByName(els.rightSearch.value);
      if (id) setChampionForSide('right', id);
    });

    els.randomFightBtn.addEventListener('click', () => {
      pickRandom('left'); pickRandom('right'); hardReset();
    });
    els.leftPickRandom.addEventListener('click', () => pickRandom('left'));
    els.rightPickRandom.addEventListener('click', () => pickRandom('right'));
    els.resetBtn.addEventListener('click', hardReset);
    els.swapBtn.addEventListener('click', swapSides);
    els.autoPlayToggle.addEventListener('change', (e) => {
      state.autoPlay = !!e.target.checked;
      if (state.autoPlay && !winner()){
        clearTimeout(state.autoplayTimer);
        state.autoplayTimer = setTimeout(()=>autoPickAndFire(state.turn), 500);
      }
    });

    // --- Init ---
    bootstrap();
  })();
  </script>
</body>
</html>