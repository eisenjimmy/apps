<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b1220">
  <title>Jimmy’s Pokémon Stadium</title>

  <!-- Favicon (Poké Ball) -->
  <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/poke-ball.png"/>

  <!-- Tailwind Play CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { ui: ['ui-sans-serif', 'system-ui', 'Segoe UI', 'Roboto', 'Helvetica', 'Arial'] },
          boxShadow: { soft: '0 8px 40px rgba(0,0,0,.32)' }
        }
      }
    }
  </script>

  <style>
    /* ===== Dark theme base ===== */
    :root{
      --bg: #0b1220;
      --bg-2: #0f172a;
      --panel: rgba(15,23,42,.85);
      --border: #1f2a44;
      --border-2:#2a3b61;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }
    .pixel { image-rendering: pixelated; image-rendering: crisp-edges; }
    .hpbar-inner { transition: width .35s ease; }
    .card {
      background: var(--panel);
      backdrop-filter: blur(10px);
      border:1px solid var(--border);
      border-radius: 1rem;
      box-shadow: 0 8px 40px rgba(0,0,0,.28);
    }
    .btn { display:inline-flex; align-items:center; justify-content:center; border-radius:.75rem; padding:.55rem 1rem; font-weight:700; color:#fff; gap:.5rem; }
    .btn:active { opacity:.92 }
    .btn-primary { background: linear-gradient(180deg, #10b981, #059669); }
    .btn-secondary { background: linear-gradient(180deg, #334155, #475569); color: var(--text); }
    .btn-warn { background: linear-gradient(180deg, #eab308, #ca8a04); color:#111827; }
    .btn-ghost { background: transparent; color: var(--muted); }
    .chip { display:inline-flex; align-items:center; gap:.25rem; border-radius:999px; padding:.25rem .625rem; font-size:.75rem; font-weight:800; background:#0b1220; color:#cbd5e1; border:1px solid var(--border-2); }
    .grid-auto-fit { display:grid; grid-template-columns: repeat(auto-fit, minmax(84px, 1fr)); gap:.75rem; }
    .tap { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
    .type-badge { font-size:10px; font-weight:900; padding:.125rem .5rem; border-radius:999px; color:#fff; }
    .move-btn { width:100%; border-radius:.75rem; padding:.5rem .75rem; font-size:.92rem; font-weight:800; color:#fff; display:flex; align-items:center; justify-content:space-between; border:1px solid rgba(255,255,255,.08); }
    .tag { font-size:10px; font-weight:800; padding:.125rem .5rem; border-radius:.5rem; background:#0f172a; color:#cbd5e1; border:1px solid var(--border); }

    /* Bottom-sheet layout + scroll fix */
    .sheet { max-height: 85vh; display: flex; flex-direction: column; }
    .sheet-scroll { flex: 1; min-height: 0; overflow-y: auto; -webkit-overflow-scrolling: touch; }
    body.no-scroll { overflow: hidden; }

    /* ====== Battle Animations ====== */
    @keyframes lunge-right { 0%{transform:translateX(0)} 40%{transform:translateX(22px)} 100%{transform:translateX(0)} }
    @keyframes lunge-left  { 0%{transform:translateX(0)} 40%{transform:translateX(-22px)} 100%{transform:translateX(0)} }
    .lunge-right { animation: lunge-right .35s ease; }
    .lunge-left  { animation: lunge-left  .35s ease; }

    @keyframes shake {
      0%,100%{ transform:translate(0,0) }
      20%{ transform:translate(-4px,0) }
      40%{ transform:translate(4px,0) }
      60%{ transform:translate(-3px,0) }
      80%{ transform:translate(3px,0) }
    }
    .shake { animation: shake .35s ease; }

    @keyframes flash { 0%{filter:brightness(1)} 50%{ filter:brightness(2)} 100%{filter:brightness(1)} }
    .flash { animation: flash .28s ease; }

    @keyframes jiggle {
      0%{transform:translate(0,0)} 25%{transform:translate(0,-2px)} 50%{transform:translate(0,0)} 75%{transform:translate(0,2px)} 100%{transform:translate(0,0)}
    }
    .camshake { animation: jiggle .25s ease; }

    /* Projectile + spark */
    .proj { position:absolute; width:10px; height:10px; border-radius:999px; box-shadow: 0 0 10px rgba(0,0,0,.45); transform: translate(-50%, -50%); pointer-events:none; }
    @keyframes spark { 0% { transform: scale(.6); opacity: 0.9; } 100% { transform: scale(1.6); opacity: 0; } }
    .spark { position:absolute; width:24px; height:24px; border-radius:50%; box-shadow: 0 0 22px rgba(255,255,255,.9), inset 0 0 12px rgba(255,255,255,.9); animation: spark .35s ease forwards; pointer-events:none; }

    /* Faint (drop + fade) */
    @keyframes faint {
      0% { transform: translateY(0); opacity: 1; filter:none; }
      100% { transform: translateY(34px); opacity: .2; filter: grayscale(100%); }
    }
    .faint { animation: faint .5s ease forwards; }

    /* ====== Gen‑1 battle layout (mobile-first GB style) ====== */
    .stage { position:relative; overflow:hidden; }
    .battle {
      position:relative; height: 320px;
      background:
        radial-gradient(ellipse at 20% 85%, rgba(255,255,255,.04), transparent 48%),
        radial-gradient(ellipse at 80% 15%, rgba(255,255,255,.04), transparent 48%);
      border-radius: .75rem; border:1px solid var(--border);
    }
    @media (min-width: 640px){ .battle { height: 380px; } }

    /* GB-style HP box (dark) */
    .hpbox { min-width: 210px; background: #0b1220; border:2px solid #334155; border-radius:.5rem; padding:.35rem .5rem .5rem; box-shadow: inset 0 0 0 2px #1e293b; color:var(--text); }
    .hpbox-title { font-weight:900; font-size:.8rem; letter-spacing:.02em; }
    .hpbox-hp { font-size:.68rem; color:#a1a1aa; display:flex; justify-content:space-between; align-items:center; }
    .hpbar { height:8px; width:100%; background:#1f2937; border-radius:999px; overflow:hidden; }

    .lv { font-size:.7rem; font-weight:900; color:#e5e7eb; }
    .st-dot { width:8px; height:8px; border-radius:999px; border:1px solid #e2e8f0; }
    .st-tag { font-size:.6rem; font-weight:900; padding:.05rem .3rem; border:1px solid #94a3b8; border-radius:.25rem; color:#e5e7eb; }

    /* Positions — player bottom-left, rival top-right */
    .opp-hp     { position:absolute; top:10px; left:10px; }
    .opp-sprite { position:absolute; top:70px; right:18px; width: 140px; height: 140px; }
    .ply-sprite { position:absolute; bottom:74px; left:18px; width: 140px; height: 140px; }
    .ply-hp     { position:absolute; bottom:10px; right:10px; }

    @media (min-width: 640px){
      .opp-sprite { width: 168px; height: 168px; top:72px; right:26px; }
      .ply-sprite { width: 168px; height: 168px; bottom:84px; left:26px; }
      .hpbox { min-width: 230px; }
    }

    /* Roster strips under HP boxes */
    .roster-strip img { border-radius: 8px; border:1px solid var(--border); }
    .roster-strip .slot { width:28px; height:28px; border-radius:8px; overflow:hidden; opacity:.95 }
    .roster-strip .active { outline:2px solid #10b981; outline-offset:1px; }
    .roster-strip .down { filter:grayscale(100%); opacity:.5 }

    /* ===== GB box (for banner & modals) ===== */
    .gb-box{
      position:relative;
      background:#0b1220;
      border:2px solid #334155;
      border-radius:.75rem;
      box-shadow:
        inset 0 0 0 2px #1e293b,
        0 10px 40px rgba(0,0,0,.35);
      color: var(--text);
    }
    .gb-box::before, .gb-box::after{
      content:"";
      position:absolute; pointer-events:none;
      border:2px solid #334155;
      width:14px; height:14px; opacity:.9;
    }
    .gb-box::before{ top:-6px; left:-6px; border-right:none; border-bottom:none; border-radius:.5rem 0 0 0; }
    .gb-box::after { bottom:-6px; right:-6px; border-left:none; border-top:none; border-radius:0 0 .5rem 0; }

    /* Blinking caret for "your turn" */
    @keyframes caret-blink { 0%,60%{opacity:1; transform:translateY(0)} 80%{opacity:.15} 100%{opacity:1; transform:translateY(1px)} }
    .gb-caret{ font-weight:900; margin-left:.5rem; display:inline-block; animation: caret-blink .9s steps(1,end) infinite; }

    /* Results modal */
    .modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 40; }
    .modal.show { display: flex; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-900 font-ui text-slate-100">
  <!-- Header -->
  <header class="sticky top-0 z-10 bg-slate-900/80 backdrop-blur border-b border-slate-800">
    <div class="max-w-5xl mx-auto px-4 py-3">
      <div class="flex items-center gap-3">
        <img alt="Poké Ball" src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/poke-ball.png" class="w-6 h-6 pixel"/>
        <h1 class="text-lg font-extrabold leading-none">Jimmy’s Pokémon Stadium</h1>
      </div>
      <div class="pl-9 text-[12px] text-slate-400">Gen‑1 layout • Lv.50 • Status • TM/HM</div>
    </div>
  </header>

  <main class="max-w-5xl mx-auto px-4 py-4 space-y-6">
    <!-- Builder -->
    <section id="builder" class="space-y-4">
      <div class="flex items-center justify-between">
        <h2 class="text-base font-bold text-slate-300">Build your teams</h2>
        <div class="flex gap-2">
          <button id="btnRandomize" class="btn btn-secondary tap">Randomize teams</button>
          <button id="btnClear" class="btn btn-ghost tap">Clear</button>
        </div>
      </div>

      <div class="grid md:grid-cols-2 gap-4">
        <div class="card p-4">
          <div class="flex items-center gap-2 mb-3">
            <span class="chip">You</span>
            <div class="text-sm text-slate-400">Choose 3 (tap Moves to pick up to 4)</div>
            <div class="ml-auto"><button id="pickA" class="btn btn-primary tap">Pick</button></div>
          </div>
          <div id="teamA" class="grid grid-cols-3 gap-3"></div>
        </div>

        <div class="card p-4">
          <div class="flex items-center gap-2 mb-3">
            <span class="chip">Rival</span>
            <div class="text-sm text-slate-400">Rival team is auto‑picked (you can edit)</div>
            <div class="ml-auto"><button id="pickB" class="btn btn-primary tap">Pick</button></div>
          </div>
          <div id="teamB" class="grid grid-cols-3 gap-3"></div>
        </div>
      </div>

      <div class="flex flex-wrap items-center gap-3 pt-2">
        <button id="startBattle" class="btn btn-warn tap disabled:opacity-50" disabled>Start Battle</button>
        <div id="buildHint" class="text-sm text-slate-400">Pick 3 for each side to begin.</div>
      </div>
    </section>

    <!-- Arena -->
    <section id="arena" class="hidden space-y-3">
      <!-- Compact top bar for mobile -->
      <div class="flex items-center gap-2">
        <span id="roundTag" class="chip">Round 1</span>
        <label class="ml-2 flex items-center gap-2 text-xs text-slate-300">
          <input id="autoPlay" type="checkbox" class="accent-emerald-500"> Auto play
        </label>
        <div class="ml-auto">
          <button id="reset" class="btn btn-secondary tap">Back to builder</button>
        </div>
      </div>

      <!-- Stage (Gen‑1 layout) -->
      <div class="card p-4 stage" id="stage">
        <div class="battle">
          <!-- Opponent HP (top-left) -->
          <div class="hpbox opp-hp">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-2">
                <span id="dotB" class="st-dot"></span>
                <div id="nameB" class="hpbox-title">???</div>
                <span id="stTextB" class="st-tag hidden">OK</span>
              </div>
              <div class="lv">Lv 50</div>
            </div>
            <div class="hpbox-hp"><span>HP <span id="hpTextB"></span></span></div>
            <div class="hpbar mt-1"><div id="hpBarB" class="hpbar-inner h-full" style="width:100%"></div></div>
            <!-- Opponent roster strip -->
            <div id="rosterB" class="roster-strip mt-2 flex gap-2"></div>
          </div>

          <!-- Opponent sprite (top-right) -->
          <img id="spriteB" class="pixel opp-sprite" alt="Opponent sprite"/>

          <!-- Player sprite (bottom-left) -->
          <img id="spriteA" class="pixel ply-sprite" alt="Your sprite"/>

          <!-- Player HP (bottom-right) -->
          <div class="hpbox ply-hp">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-2">
                <span id="dotA" class="st-dot"></span>
                <div id="nameA" class="hpbox-title">???</div>
                <span id="stTextA" class="st-tag hidden">OK</span>
              </div>
              <div class="lv">Lv 50</div>
            </div>
            <div class="hpbox-hp"><span>HP <span id="hpTextA"></span></span></div>
            <div class="hpbar mt-1"><div id="hpBarA" class="hpbar-inner h-full" style="width:100%"></div></div>
            <!-- Player roster strip -->
            <div id="rosterA" class="roster-strip mt-2 flex gap-2 justify-end"></div>
          </div>
        </div>

        <!-- Turn banner (GB border + blinking caret on your turn) -->
        <div id="turnBanner" class="gb-box mt-4 p-3 text-sm ring-2 ring-slate-600" aria-live="polite">
          Ready! <span id="gbCaret" class="gb-caret hidden">►</span>
        </div>

        <!-- Move buttons -->
        <div class="mt-3 grid grid-cols-2 gap-2" id="moveButtons"></div>

        <div class="mt-2 flex items-center gap-2">
          <button id="btnNext" class="btn btn-secondary tap disabled:opacity-50" disabled>Next</button>
        </div>
      </div>

      <!-- (Log hidden by default; kept for debugging) -->
      <details class="card p-3">
        <summary class="text-sm cursor-pointer text-slate-300">Show battle log (debug)</summary>
        <ol id="log" class="space-y-2 text-sm max-h-80 overflow-auto pr-1 mt-2 text-slate-300"></ol>
        <div class="mt-2"><button id="clearLog" class="btn btn-ghost tap">Clear log</button></div>
      </details>
    </section>
  </main>

  <!-- Team Picker Overlay -->
  <div id="picker" class="fixed inset-0 z-20 hidden">
    <div class="absolute inset-0 bg-black/50" data-close></div>
    <div class="absolute inset-x-0 bottom-0 sheet rounded-t-3xl bg-slate-900 p-4 space-y-3 border-t border-slate-800">
      <div class="flex items-center gap-2">
        <div id="pickerLabel" class="chip">Pick — You</div>
        <input id="search" type="text" placeholder="Search Pokémon…" class="ml-auto w-full max-w-xs px-3 py-2 rounded-xl border border-slate-700 bg-slate-800 text-slate-100 placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-emerald-400" />
        <button id="donePick" class="btn btn-secondary tap">Done</button>
      </div>
      <div id="pickedCount" class="text-xs text-slate-400">0 / 3 selected</div>
      <div class="sheet-scroll pr-1">
        <div id="grid" class="grid-auto-fit"></div>
      </div>
    </div>
  </div>

  <!-- Move Picker Overlay -->
  <div id="movePicker" class="fixed inset-0 z-30 hidden">
    <div class="absolute inset-0 bg-black/50" data-close-mv></div>
    <div class="absolute inset-x-0 bottom-0 sheet rounded-t-3xl bg-slate-900 p-4 space-y-3 border-t border-slate-800">
      <div class="flex items-center gap-2">
        <div id="mvTitle" class="chip">Moves — ???</div>
        <div class="ml-auto flex items-center gap-2 text-xs">
          <label class="flex items-center gap-1 text-slate-300"><input id="fltLvl" type="checkbox" class="accent-emerald-500" checked><span>Level‑Up ≤50</span></label>
          <label class="flex items-center gap-1 text-slate-300"><input id="fltTM" type="checkbox" class="accent-emerald-500" checked><span>TM/HM</span></label>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <input id="mvSearch" type="text" placeholder="Search moves…" class="w-full px-3 py-2 rounded-xl border border-slate-700 bg-slate-800 text-slate-100 placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-emerald-400" />
        <button id="mvRecommend" class="btn btn-secondary tap">Recommend 4</button>
        <button id="mvClear" class="btn btn-ghost tap">Clear</button>
        <button id="mvDone" class="btn btn-primary tap">Done</button>
      </div>
      <div id="mvPickedCount" class="text-xs text-slate-400">0 / 4 selected</div>
      <div class="sheet-scroll pr-1">
        <div id="mvList" class="space-y-2"></div>
      </div>
    </div>
  </div>

  <!-- Results Modal -->
  <div id="resultModal" class="modal">
    <div class="gb-box max-w-md w-[92%] p-5 bg-slate-900">
      <div id="resultTitle" class="text-2xl font-extrabold text-center mb-2">You Win!</div>
      <div id="resultSubtitle" class="text-center text-slate-400 mb-4">Battle Summary</div>
      <div class="grid grid-cols-2 gap-3 text-sm mb-4">
        <div class="border border-slate-700 rounded-lg p-3">
          <div class="font-bold mb-1">Rounds</div>
          <div id="rsRounds">—</div>
        </div>
        <div class="border border-slate-700 rounded-lg p-3">
          <div class="font-bold mb-1">KOs</div>
          <div id="rsKO">You — / Rival —</div>
        </div>
        <div class="border border-slate-700 rounded-lg p-3">
          <div class="font-bold mb-1">Damage (You)</div>
          <div id="rsDmgA">—</div>
        </div>
        <div class="border border-slate-700 rounded-lg p-3">
          <div class="font-bold mb-1">Damage (Rival)</div>
          <div id="rsDmgB">—</div>
        </div>
        <div class="border border-slate-700 rounded-lg p-3 col-span-2">
          <div class="font-bold mb-1">Statuses Inflicted</div>
          <div id="rsStatus" class="flex flex-wrap gap-2 text-[12px]"></div>
        </div>
      </div>
      <div class="flex gap-2 justify-center">
        <button id="btnRematch" class="btn btn-primary tap">Try Again?</button>
        <button id="btnBack" class="btn btn-secondary tap">Back to Builder</button>
      </div>
    </div>
  </div>

  <footer class="max-w-5xl mx-auto px-4 py-8 text-center text-xs text-slate-500">
    Data & sprites from <a class="underline" href="https://pokeapi.co/" target="_blank" rel="noreferrer">PokéAPI</a>.
  </footer>

  <script>
    /* ======= Utils & Constants ======= */
    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));
    const sleep = ms => new Promise(r => setTimeout(r, ms));
    const cap = s => s.charAt(0).toUpperCase() + s.slice(1);
    const gridSpriteURL = id => `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`;

    // No more "Pace" control — keep timing stable
    const P = (ms) => ms;

    // Static fallback Kanto names (1..151) for offline/failed fetch
    const KANTO_FALLBACK = ["Bulbasaur","Ivysaur","Venusaur","Charmander","Charmeleon","Charizard","Squirtle","Wartortle","Blastoise","Caterpie","Metapod","Butterfree","Weedle","Kakuna","Beedrill","Pidgey","Pidgeotto","Pidgeot","Rattata","Raticate","Spearow","Fearow","Ekans","Arbok","Pikachu","Raichu","Sandshrew","Sandslash","Nidoran♀","Nidorina","Nidoqueen","Nidoran♂","Nidorino","Nidoking","Clefairy","Clefable","Vulpix","Ninetales","Jigglypuff","Wigglytuff","Zubat","Golbat","Oddish","Gloom","Vileplume","Paras","Parasect","Venonat","Venomoth","Diglett","Dugtrio","Meowth","Persian","Psyduck","Golduck","Mankey","Primeape","Growlithe","Arcanine","Poliwag","Poliwhirl","Poliwrath","Abra","Kadabra","Alakazam","Machop","Machoke","Machamp","Bellsprout","Weepinbell","Victreebel","Tentacool","Tentacruel","Geodude","Graveler","Golem","Ponyta","Rapidash","Slowpoke","Slowbro","Magnemite","Magneton","Farfetch’d","Doduo","Dodrio","Seel","Dewgong","Grimer","Muk","Shellder","Cloyster","Gastly","Haunter","Gengar","Onix","Drowzee","Hypno","Krabby","Kingler","Voltorb","Electrode","Exeggcute","Exeggutor","Cubone","Marowak","Hitmonlee","Hitmonchan","Lickitung","Koffing","Weezing","Rhyhorn","Rhydon","Chansey","Tangela","Kangaskhan","Horsea","Seadra","Goldeen","Seaking","Staryu","Starmie","Mr. Mime","Scyther","Jynx","Electabuzz","Magmar","Pinsir","Tauros","Magikarp","Gyarados","Lapras","Ditto","Eevee","Vaporeon","Jolteon","Flareon","Porygon","Omanyte","Omastar","Kabuto","Kabutops","Aerodactyl","Snorlax","Articuno","Zapdos","Moltres","Dratini","Dragonair","Dragonite","Mewtwo","Mew"];

    const TYPE_COLORS = {
      normal:'#A8A77A', fire:'#EE8130', water:'#6390F0', electric:'#F7D02C', grass:'#7AC74C',
      ice:'#96D9D6', fighting:'#C22E28', poison:'#A33EA1', ground:'#E2BF65', flying:'#A98FF3',
      psychic:'#F95587', bug:'#A6B91A', rock:'#B6A136', ghost:'#735797', dragon:'#6F35FC'
    };
    const SPECIAL_TYPES = new Set(['fire','water','grass','electric','ice','psychic','dragon']);
    const typeColor = t => TYPE_COLORS[t] || '#64748b';

    // Gen‑1 type chart
    const chart = {
      normal:{ rock:0.5, ghost:0 },
      fire:{ fire:0.5, water:0.5, grass:2, ice:2, bug:2, rock:0.5, dragon:0.5 },
      water:{ fire:2, water:0.5, grass:0.5, ground:2, rock:2, dragon:0.5 },
      electric:{ water:2, electric:0.5, grass:0.5, ground:0, flying:2, dragon:0.5 },
      grass:{ fire:0.5, water:2, grass:0.5, poison:0.5, ground:2, flying:0.5, bug:0.5, rock:2, dragon:0.5 },
      ice:{ water:0.5, ice:0.5, grass:2, ground:2, flying:2, dragon:2 },
      fighting:{ normal:2, ice:2, poison:0.5, flying:0.5, psychic:0.5, bug:0.5, rock:2, ghost:0 },
      poison:{ grass:2, poison:0.5, ground:0.5, rock:0.5, ghost:0.5 },
      ground:{ fire:2, electric:2, grass:0.5, poison:2, flying:0, bug:0.5, rock:2 },
      flying:{ electric:0.5, grass:2, fighting:2, bug:2, rock:0.5 },
      psychic:{ fighting:2, poison:2, psychic:0.5 },
      bug:{ fire:0.5, grass:2, fighting:0.5, poison:2, flying:0.5, psychic:2, ghost:0.5 },
      rock:{ fire:2, ice:2, fighting:0.5, ground:0.5, flying:2, bug:2 },
      ghost:{ normal:0, psychic:0, ghost:2 },
      dragon:{ dragon:2 }
    };
    function effMultiplier(moveType, targetTypes){ let mult = 1; for(const t of targetTypes){ mult *= (chart[moveType]?.[t] ?? 1); } return mult; }

    // Status constants
    const PAR_SPEED = 0.5;      // paralysis speed modifier
    const RESIDUAL_FRACTION = 16; // 1/16 max HP

    const AIL_MAP = {
      paralysis:'par', burn:'brn', poison:'psn', 'bad-poison':'psn', freeze:'frz', sleep:'slp',
      confusion:'cnf'
    };

    /* ======= App State ======= */
    const state = {
      allPokemon: [],
      teamA: [], teamB: [],
      pickingFor: 'A', tempPick: new Set(),
      // Move editor
      mvContext: null,
      mvTemp: new Set(),
      mvPoolCache: new Map(),
      moveCache: new Map(),
      typesById: new Map(),
      // Battle
      rosterA: [], rosterB: [], aIdx:0, bIdx:0, round:1,
      waitingForPlayerChoice:true, queuedMove:null, autoPlay:false, lock:false,
      // Results tracking
      stats: { rounds:0, dmgA:0, dmgB:0, koA:0, koB:0, statusCounts: {par:0, brn:0, psn:0, frz:0, slp:0} }
    };

    /* ======= Boot ======= */
    document.addEventListener('DOMContentLoaded', async () => {
      renderTeams(); wireBuilder(); wireArena(); wireResults();
      await loadKanto();   // seeds Rival after list ready
    });

    // Fetch with timeout
    async function fetchWithTimeout(url, ms=6000){
      const ctl = new AbortController();
      const t = setTimeout(()=>ctl.abort(), ms);
      try { const r = await fetch(url, {signal: ctl.signal}); clearTimeout(t); return r; }
      catch(e){ clearTimeout(t); throw e; }
    }

    async function loadKanto(){
      try {
        const res = await fetchWithTimeout('https://pokeapi.co/api/v2/pokemon?limit=151');
        if(!res.ok) throw new Error('HTTP '+res.status);
        const data = await res.json();
        state.allPokemon = data.results.map((p,i)=>({id:i+1, name:cap(p.name)}));
      } catch (e) {
        console.warn('Falling back to built-in Kanto list:', e);
        state.allPokemon = KANTO_FALLBACK.map((name,i)=>({id:i+1, name}));
        toast('Using offline Kanto list.');
      }
      renderGrid();
      autoSeedRival();
      renderTeams();
      updateStartButton();
    }

    /* ======= Builder ======= */
    function wireBuilder(){
      $('#pickA').addEventListener('click', ()=>openPicker('A'));
      $('#pickB').addEventListener('click', ()=>openPicker('B'));
      $('#btnClear').addEventListener('click', ()=>{
        state.teamA=[]; state.teamB=[];
        autoSeedRival();
        renderTeams(); updateStartButton();
      });
      $('#btnRandomize').addEventListener('click', ()=>{
        const ids = Array.from({length:151},(_,i)=>i+1); shuffle(ids);
        state.teamA = ids.slice(0,3).map(id=>({id,name:nameFor(id)}));
        state.teamB = ids.slice(3,6).map(id=>({id,name:nameFor(id)}));
        renderTeams(); updateStartButton();
      });
      $('#startBattle').addEventListener('click', startBattle);
    }

    function wireResults(){
      $('#btnBack').addEventListener('click', ()=>{ hideResult(); $('#arena').classList.add('hidden'); $('#builder').classList.remove('hidden'); });
      $('#btnRematch').addEventListener('click', ()=>{ hideResult(); startBattle(); });
    }

    function autoSeedRival(){
      if(!state.allPokemon?.length) return;
      const ids = Array.from({length:151},(_,i)=>i+1);
      shuffle(ids);
      state.teamB = ids.slice(0,3).map(id=>({ id, name: nameFor(id) }));
    }

    function nameFor(id){ const p=state.allPokemon.find(x=>x.id===id); return p?p.name:`#${id}`; }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

    function renderTeams(){
      const moveChips = (p) => {
        const list = p.moves?.slice(0,4) || [];
        if(!list.length) return '<span class="text-[10px] text-slate-400">No moves chosen</span>';
        return list.map(n=>`<span class="tag">${cleanMoveName(n)}</span>`).join(' ');
      };
      const slot = (teamKey, p, idx) => `
        <div class="card p-2 flex flex-col items-center">
          <img src="${gridSpriteURL(p.id)}" alt="${p.name}" class="w-16 h-16 pixel"/>
          <div class="text-xs mt-1 text-center">${p.name}</div>
          <div class="mt-2 flex items-center gap-2">
            <button class="btn-ghost text-xs tap" data-mv>Edit Moves</button>
            <button class="btn-ghost text-xs tap text-rose-400" data-remove>Remove</button>
          </div>
          <div class="mt-2 flex flex-wrap gap-1 justify-center">${moveChips(p)}</div>
        </div>`;
      const filler = `<div class="rounded-2xl border border-dashed border-slate-700 h-24 flex items-center justify-center text-slate-500 text-xs">Empty</div>`;

      const mount=(el, teamKey)=>{
        el.innerHTML='';
        const team = state[teamKey];
        team.forEach((p, idx)=>{
          const wrap=document.createElement('div'); wrap.innerHTML=slot(teamKey,p,idx);
          wrap.querySelector('[data-remove]').addEventListener('click', ()=>{ team.splice(idx,1); renderTeams(); updateStartButton(); });
          wrap.querySelector('[data-mv]').addEventListener('click', ()=> openMovePicker(teamKey, p.id, p.name));
          el.appendChild(wrap.firstElementChild);
        });
        for(let i=team.length;i<3;i++){ const d=document.createElement('div'); d.innerHTML=filler; el.appendChild(d.firstElementChild); }
      };
      mount($('#teamA'), 'teamA'); mount($('#teamB'), 'teamB');
      updateStartButton();
    }

    function updateStartButton(){
      const ok=state.teamA.length===3 && state.teamB.length===3;
      $('#startBattle').disabled=!ok;
      $('#buildHint').textContent = ok ? 'Optionally edit moves, then Start Battle.' : 'Pick 3 for each side to begin.';
    }

    /* ======= Team Picker ======= */
    function openPicker(team){
      state.pickingFor=team;
      state.tempPick = new Set((team==='A'?state.teamA:state.teamB).map(p=>p.id));
      $('#pickerLabel').textContent=`Pick — ${team==='A'?'You':'Rival'}`;
      $('#pickedCount').textContent=`${state.tempPick.size} / 3 selected`;
      document.body.classList.add('no-scroll');
      $('#picker').classList.remove('hidden');
      if(!state.allPokemon.length){ state.allPokemon = KANTO_FALLBACK.map((n,i)=>({id:i+1, name:n})); }
      $('#search').value=''; filterGrid('');
      if(!$('#grid').children.length) renderGrid();
    }
    function closePicker(commit=false){
      if(commit){
        const list = Array.from(state.tempPick).slice(0,3).map(id=>{
          const existing = (state.pickingFor==='A'?state.teamA:state.teamB).find(x=>x.id===id);
          return existing ? existing : ({id, name:nameFor(id)});
        });
        if(state.pickingFor==='A') state.teamA=list; else state.teamB=list;
        renderTeams(); updateStartButton();
      }
      $('#picker').classList.add('hidden');
      document.body.classList.remove('no-scroll');
    }
    $('#donePick').addEventListener('click', ()=>closePicker(true));
    $('#picker').addEventListener('click', (e)=>{ if(e.target.hasAttribute('data-close')) closePicker(false); });
    $('#search').addEventListener('input', (e)=>filterGrid(e.target.value.trim().toLowerCase()));

    function renderGrid(){
      const grid=$('#grid'); grid.innerHTML='';
      state.allPokemon.forEach(p=>{
        const card=document.createElement('button');
        card.className='tap rounded-2xl border border-slate-700 bg-slate-800 p-2 flex flex-col items-center hover:border-emerald-400 focus:outline-none';
        card.setAttribute('data-id', p.id);
        card.innerHTML=`<img src="${gridSpriteURL(p.id)}" alt="${p.name}" class="w-14 h-14 pixel"/><div class="text-xs mt-1">${p.name}</div>`;
        card.addEventListener('click', ()=>toggleTempPick(p.id, card));
        grid.appendChild(card);
      });
    }
    function filterGrid(q){
      $$('#grid [data-id]').forEach(el=>{
        const id=Number(el.getAttribute('data-id'));
        const name=nameFor(id).toLowerCase();
        const match=!q || name.includes(q) || String(id).padStart(3,'0').includes(q);
        el.classList.toggle('hidden', !match);
        reflectPickedUI(id, el);
      });
    }
    function toggleTempPick(id, el){
      if(state.tempPick.has(id)) state.tempPick.delete(id);
      else { if(state.tempPick.size>=3) return; state.tempPick.add(id); }
      $('#pickedCount').textContent=`${state.tempPick.size} / 3 selected`;
      reflectPickedUI(id, el);
    }
    function reflectPickedUI(id, el){ const picked=state.tempPick.has(id); el.style.borderColor=picked?'#10b981':'#334155'; el.style.boxShadow=picked?'0 0 0 3px rgba(16,185,129,.25)':'none'; }

    /* ======= Move Picker ======= */
    async function openMovePicker(team, id, name){
      $('#mvTitle').textContent = `Moves — ${name} (${team==='A'?'You':'Rival'})`;
      $('#mvPickedCount').textContent = `0 / 4 selected`;
      $('#mvSearch').value=''; $('#fltLvl').checked = true; $('#fltTM').checked = true;
      state.mvContext = {team, id, name, types: null};
      document.body.classList.add('no-scroll');
      $('#movePicker').classList.remove('hidden');

      const pool = await getMovePool(id);
      const types = state.typesById.get(id) || [];
      state.mvContext.types = types;

      const teamArr = state[team === 'A' ? 'teamA' : 'teamB'];
      const entry = teamArr.find(x=>x.id===id);
      state.mvTemp = new Set((entry?.moves || []).slice(0,4));

      renderMoveList();
    }
    function closeMovePicker(commit=false){
      if(commit){
        const teamArr = state[state.mvContext.team === 'A' ? 'teamA' : 'teamB'];
        const entry = teamArr.find(x=>x.id===state.mvContext.id);
        if(entry) entry.moves = Array.from(state.mvTemp).slice(0,4);
        renderTeams();
      }
      $('#movePicker').classList.add('hidden');
      document.body.classList.remove('no-scroll');
      state.mvContext = null; state.mvTemp = new Set();
    }
    document.addEventListener('click', (e)=>{
      if(e.target.hasAttribute?.('data-close-mv')) closeMovePicker(false);
    });
    $('#mvDone').addEventListener('click', ()=>closeMovePicker(true));
    $('#mvClear').addEventListener('click', ()=>{ state.mvTemp.clear(); renderMoveList(); });
    $('#mvRecommend').addEventListener('click', ()=>{
      const pool = getFilteredMovePool();
      const picks = recommendMoves(pool, state.mvContext.types).slice(0,4).map(m=>m.key);
      state.mvTemp = new Set(picks);
      renderMoveList();
    });
    $('#mvSearch').addEventListener('input', renderMoveList);
    $('#fltLvl').addEventListener('change', renderMoveList);
    $('#fltTM').addEventListener('change', renderMoveList);

    function renderMoveList(){
      const list = $('#mvList'); list.innerHTML='';
      const q = $('#mvSearch').value.trim().toLowerCase();
      const filtered = getFilteredMovePool().filter(m=>{
        return !q || m.display.toLowerCase().includes(q) || m.type.includes(q);
      });

      filtered.sort((a,b)=>{
        const stabA = state.mvContext.types?.includes(a.type) ? 1 : 0;
        const stabB = state.mvContext.types?.includes(b.type) ? 1 : 0;
        const catA = a.category==='status'? -1 : 1;
        const catB = b.category==='status'? -1 : 1;
        return (stabB-stabA) || (catB-catA) || ((b.power||0) - (a.power||0)) || ((b.level||0) - (a.level||0)) || (a.method==='machine'?1:-1);
      });

      for(const m of filtered){
        const row = document.createElement('button');
        const picked = state.mvTemp.has(m.key);
        row.className = 'w-full border border-slate-700 rounded-xl p-2 flex items-center gap-3 tap bg-slate-800';
        row.style.boxShadow = picked ? '0 0 0 3px rgba(16,185,129,.20)' : 'none';
        const ail = m.ailment_code ? ` • ${m.ailment_code.toUpperCase()}${m.ailment_chance?(' '+m.ailment_chance+'%'):''}` : '';
        row.innerHTML = `
          <span class="type-badge" style="background:${typeColor(m.type)}">${m.type.toUpperCase()}</span>
          <div class="flex-1 text-left">
            <div class="font-bold">${m.display}</div>
            <div class="text-[11px] text-slate-400">
              ${m.category==='status' ? 'Status' : ('Pow ' + (m.power ?? '—'))}
              • Acc ${m.accuracy ?? '—'}%
              • ${cap(m.category)}${ail}
              • ${m.method==='machine' ? 'TM/HM' : ('Lv ' + (m.level||'?'))}
              ${m.sources?.length? '• ' + m.sources.map(src=>src==='red-blue'?'RB':'Y').join('/') : ''}
            </div>
          </div>
          <div class="text-[11px] px-2 py-1 rounded-md ${picked?'bg-emerald-100 text-emerald-700':'bg-slate-700 text-slate-200'}">${picked?'Selected':'Select'}</div>
        `;
        row.addEventListener('click', ()=>{
          if(picked){ state.mvTemp.delete(m.key); }
          else {
            if(state.mvTemp.size>=4) { toast('Max 4 moves.'); return; }
            state.mvTemp.add(m.key);
          }
          $('#mvPickedCount').textContent = `${state.mvTemp.size} / 4 selected`;
          renderMoveList();
        });
        list.appendChild(row);
      }
      $('#mvPickedCount').textContent = `${state.mvTemp.size} / 4 selected`;
    }
    function getFilteredMovePool(){
      const pool = state.mvPoolCache.get(state.mvContext.id) || [];
      const incLvl = $('#fltLvl').checked, incTM = $('#fltTM').checked;
      return pool.filter(m => (m.method==='level-up' && incLvl) || (m.method==='machine' && incTM));
    }

    async function getMovePool(id){
      if(state.mvPoolCache.has(id)) return state.mvPoolCache.get(id);
      const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
      const p = await res.json();
      const types = p.types.sort((a,b)=>a.slot-b.slot).map(t=>t.type.name);
      state.typesById.set(id, types);
      const pool = await assembleGen1MovePool(p.moves);
      state.mvPoolCache.set(id, pool);
      return pool;
    }

    async function assembleGen1MovePool(movesArray){
      const vgOK = new Set(['red-blue','yellow']);
      const agg = new Map();
      for(const m of movesArray){
        for(const v of m.version_group_details){
          if(!vgOK.has(v.version_group.name)) continue;
          const method = v.move_learn_method.name;
          if(method==='level-up' && v.level_learned_at>50) continue;
          if(method!=='level-up' && method!=='machine') continue;
          const key = m.move.name;
          if(!agg.has(key)) agg.set(key, {name:key, methods:new Set(), level:null, sources:new Set()});
          const rec = agg.get(key);
          rec.methods.add(method);
          rec.sources.add(v.version_group.name);
          if(method==='level-up'){ rec.level = Math.max(rec.level||0, v.level_learned_at||0); }
        }
      }
      const out = [];
      for(const {name, methods, level, sources} of agg.values()){
        if(!state.moveCache.has(name)){
          const r = await fetch(`https://pokeapi.co/api/v2/move/${name}`);
          const mv = await r.json();
          state.moveCache.set(name, mv);
        }
        const mv = state.moveCache.get(name);
        const type = mv.type?.name;
        if(!(type in TYPE_COLORS)) continue;
        const category = mv.damage_class?.name || 'status';
        const power = mv.power ?? null;
        const accuracy = mv.accuracy ?? 100;

        // Ailment
        const ailmentRaw = mv.meta?.ailment?.name || 'none';
        const ailment_chance = mv.meta?.ailment_chance ?? mv.effect_chance ?? 0;
        const ailment_code = AIL_MAP[ailmentRaw] || (ailmentRaw==='none'? null : ailmentRaw);

        if(methods.has('level-up')){
          out.push({ key:name, display:cleanMoveName(name), type, category,
            power, accuracy, method:'level-up', level:level||1, sources:[...sources],
            ailment_code, ailment_chance });
        }
        if(methods.has('machine')){
          out.push({ key:name, display:cleanMoveName(name), type, category,
            power, accuracy, method:'machine', level:null, sources:[...sources],
            ailment_code, ailment_chance });
        }
      }
      return out;
    }

    function cleanMoveName(n){ return n.replace(/-/g,' ').replace(/\b\w/g,c=>c.toUpperCase()); }

    function recommendMoves(pool, attackerTypes=[]){
      const scored = pool.map(m=>{
        const stab = attackerTypes.includes(m.type) ? 1.5 : 1.0;
        const base = m.category==='status' ? 40 + (m.ailment_code?20:0) : (m.power||0) * stab;
        const score = base + ((m.level||0)/5) + (m.method==='level-up'? 1 : 0);
        return {score, m};
      });
      scored.sort((a,b)=> b.score - a.score);
      const seen=new Set(), picks=[];
      for(const s of scored){ if(!seen.has(s.m.key)){ seen.add(s.m.key); picks.push(s.m); } if(picks.length>=4) break; }
      if(!picks.length){ picks.push({key:'tackle', display:'Tackle', type:'normal', category:'physical', power:40, accuracy:100, method:'level-up', level:1}); }
      return picks;
    }

    /* ======= Arena ======= */
    function wireArena(){
      $('#reset').addEventListener('click', ()=>{ $('#arena').classList.add('hidden'); $('#builder').classList.remove('hidden'); clearLog(); });
      const clearBtn = $('#clearLog'); if(clearBtn) clearBtn.addEventListener('click', clearLog);
      $('#btnNext').addEventListener('click', async ()=>{ if(!state.waitingForPlayerChoice && !state.lock) await resolveTurn(); });
      $('#autoPlay').addEventListener('change', (e)=>{ state.autoPlay=e.target.checked; if(state.autoPlay) autoLoop(); });
    }

    async function startBattle(){
      $('#builder').classList.add('hidden'); $('#arena').classList.remove('hidden'); clearLog();
      // Reset results
      state.stats = { rounds:0, dmgA:0, dmgB:0, koA:0, koB:0, statusCounts: {par:0, brn:0, psn:0, frz:0, slp:0} };
      state.rosterA=[]; state.rosterB=[]; state.aIdx=0; state.bIdx=0; state.round=1; state.waitingForPlayerChoice=true; state.queuedMove=null; state.lock=false;

      const all6=[...state.teamA, ...state.teamB];
      const details = await Promise.all(all6.map(async (p)=>{
        const mon = await buildMon(p.id);
        if(p.moves && p.moves.length){
          const want = p.moves.slice(0,4);
          const pool = state.mvPoolCache.get(p.id) || await getMovePool(p.id);
          const byKey = new Map(pool.map(x=>[x.key,x]));
          const chosen = [];
          for(const k of want){ if(byKey.has(k)) chosen.push(byKey.get(k)); }
          if(chosen.length){ mon.moves = chosen; }
        }
        return mon;
      }));
      state.rosterA = details.slice(0,3);
      state.rosterB = details.slice(3,6);

      updateRosterBadges(); setActiveDisplays(); renderMoveButtons();
      setBanner(`Your turn — choose a move for ${currA().name}.`, 'your');
      enableMoveButtons(true);
      if(state.autoPlay) autoLoop();
    }

    async function buildMon(id){
      const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
      const p = await res.json();
      const getStat = k => p.stats.find(s=>s.stat.name===k).base_stat;
      const L=50;
      const base = { hp:getStat('hp'), atk:getStat('attack'), def:getStat('defense'), spa:getStat('special-attack'), spd:getStat('special-defense'), spe:getStat('speed') };
      const derived = {
        maxHP: Math.floor(((2*base.hp)*L)/100) + L + 10,
        atk: Math.floor(((2*base.atk)*L)/100) + 5,
        def: Math.floor(((2*base.def)*L)/100) + 5,
        spa: Math.floor(((2*base.spa)*L)/100) + 5,
        spd: Math.floor(((2*base.spd)*L)/100) + 5,
        spe: Math.floor(((2*base.spe)*L)/100) + 5,
      };
      const types = p.types.sort((a,b)=>a.slot-b.slot).map(t=>t.type.name);
      state.typesById.set(id, types);

      const pool = state.mvPoolCache.get(id) || await assembleGen1MovePool(p.moves);
      state.mvPoolCache.set(id, pool);
      const moves = recommendMoves(pool, types).slice(0,4);

      return {
        id, name:cap(p.name), types,
        front:p.sprites.front_default || gridSpriteURL(id),
        back: p.sprites.back_default || p.sprites.front_default || gridSpriteURL(id),
        base, stats:{...derived}, hp:derived.maxHP, moves,
        status:null
      };
    }

    // Helpers
    const currA=()=>state.rosterA[state.aIdx];
    const currB=()=>state.rosterB[state.bIdx];

    function updateRosterBadges(){
      // Small GB-like icons inside the HP boxes (under bars)
      const mk=(mon,isActive)=>`
        <div class="slot ${isActive?'active':''} ${mon.hp>0?'':'down'}">
          <img class="w-7 h-7 pixel" src="${gridSpriteURL(mon.id)}" alt="${mon.name}">
        </div>`;
      $('#rosterA').innerHTML = state.rosterA.map((m,i)=>mk(m,i===state.aIdx)).join('');
      $('#rosterB').innerHTML = state.rosterB.map((m,i)=>mk(m,i===state.bIdx)).join('');
    }

    function setActiveDisplays(){
      const A=currA(), B=currB();
      $('#nameA').textContent=A.name; $('#nameB').textContent=B.name;
      $('#spriteA').src=A.back; $('#spriteB').src=B.front;
      setHPBars(); $('#roundTag').textContent=`Round ${state.round}`;
      updateRosterBadges(); renderMoveButtons();
    }

    function setHPBars(){
      const A=currA(), B=currB();
      const pctA=Math.max(0, Math.round((A.hp/A.stats.maxHP)*100));
      const pctB=Math.max(0, Math.round((B.hp/B.stats.maxHP)*100));
      const colorHP=(el,pct)=>{ if(pct>50){el.style.background='linear-gradient(90deg,#22c55e,#16a34a)';}
        else if(pct>20){el.style.background='linear-gradient(90deg,#f59e0b,#d97706)';}
        else {el.style.background='linear-gradient(90deg,#ef4444,#dc2626)';} };
      $('#hpBarA').style.width=pctA+'%'; colorHP($('#hpBarA'), pctA);
      $('#hpBarB').style.width=pctB+'%'; colorHP($('#hpBarB'), pctB);
      $('#hpTextA').textContent=`${A.hp} / ${A.stats.maxHP}`;
      $('#hpTextB').textContent=`${B.hp} / ${B.stats.maxHP}`;
      updateStatusUI('A', A); updateStatusUI('B', B);
    }

    function updateStatusUI(side, mon){
      const dot = side==='A'? $('#dotA') : $('#dotB');
      const tag = side==='A'? $('#stTextA') : $('#stTextB');
      let color='#10b981', label=null;
      if(mon.status?.type){
        label = mon.status.type.toUpperCase();
        switch(mon.status.type){
          case 'par': color='#fbbf24'; break;
          case 'brn': color='#f97316'; break;
          case 'psn': color='#8b5cf6'; break;
          case 'frz': color='#22d3ee'; break;
          case 'slp': color='#94a3b8'; break;
          default: color='#10b981';
        }
      } else {
        const pct = Math.round((mon.hp/mon.stats.maxHP)*100);
        if(pct<=20) color='#ef4444';
        else if(pct<=50) color='#f59e0b';
      }
      dot.style.backgroundColor=color;
      if(label){ tag.textContent=label; tag.classList.remove('hidden'); }
      else { tag.classList.add('hidden'); }
    }

    function renderMoveButtons(){
      const A=currA(); const box=$('#moveButtons'); box.innerHTML='';
      A.moves.forEach((m)=>{
        const btn=document.createElement('button');
        btn.className='move-btn tap';
        btn.style.background = `linear-gradient(180deg, ${typeColor(m.type)}, #1f2937)`;
        const ail = m.ailment_code ? ` • ${m.ailment_code.toUpperCase()}${m.ailment_chance?(' '+m.ailment_chance+'%'):''}` : '';
        btn.innerHTML = `
          <div class="text-left">
            <div class="font-extrabold">${m.display}</div>
            <div class="text-[10px] opacity-90">
              ${m.category==='status' ? 'Status' : ('Pow ' + (m.power ?? '—'))}
              • Acc ${m.accuracy ?? '—'}% • ${cap(m.category)}${ail}
            </div>
          </div>
          <span class="type-badge" style="background:${typeColor(m.type)}">${m.type.toUpperCase()}</span>
        `;
        btn.addEventListener('click', async ()=>{
          if(state.lock || !state.waitingForPlayerChoice) return;
          state.queuedMove = m;
          await resolveTurn();
        });
        box.appendChild(btn);
      });
      enableMoveButtons(state.waitingForPlayerChoice);
    }

    function enableMoveButtons(on){
      $$('#moveButtons .move-btn').forEach(b=>{
        b.disabled = !on;
        b.style.opacity = on ? '1' : '.65';
        b.style.filter = on ? 'none' : 'grayscale(35%)';
        b.style.cursor = on ? 'pointer' : 'not-allowed';
      });
    }

    async function autoLoop(){
      while(state.autoPlay && battleAlive()){
        if(state.waitingForPlayerChoice){
          const A=currA(), B=currB();
          state.queuedMove = bestMoveAgainst(A, B);
        }
        await resolveTurn();
        await sleep(P(700));
      }
    }

    function battleAlive(){
      const aliveA=state.rosterA.some(m=>m.hp>0);
      const aliveB=state.rosterB.some(m=>m.hp>0);
      return aliveA && aliveB;
    }

    function effectiveSpeed(mon){
      let s = mon.stats.spe;
      if(mon.status?.type==='par') s = Math.floor(s * PAR_SPEED);
      return s;
    }

    function bestMoveAgainst(attacker, defender){
      let best = attacker.moves[0];
      let bestScore = -1;
      for(const m of attacker.moves){
        let score;
        if(m.category==='status'){
          const willDoAnything = !defender.status?.type && m.ailment_code;
          score = willDoAnything ? 50 + (m.ailment_chance||0) : 10;
        } else {
          score = estimateDamage(attacker, defender, m);
          if(m.ailment_code) score += (m.ailment_chance||0)/2;
        }
        if(score>bestScore){ bestScore=score; best=m; }
      }
      return best;
    }

    function setBanner(text, mode='info'){
      const b = $('#turnBanner');
      const caret = $('#gbCaret');
      b.textContent = text + ' ';
      b.appendChild(caret);
      const ring = mode==='your' ? 'ring-emerald-500' : mode==='rival' ? 'ring-rose-500' : 'ring-slate-600';
      b.className = `gb-box mt-4 p-3 text-sm ring-2 ${ring}`;
      if(mode==='your'){ caret.classList.remove('hidden'); }
      else { caret.classList.add('hidden'); }
    }

    async function resolveTurn(){
      if(state.lock) return; state.lock=true;
      if(state.waitingForPlayerChoice && !state.queuedMove){
        toast('Choose a move.'); state.lock=false; return;
      }

      const A=currA(), B=currB();
      const cpuMove = bestMoveAgainst(B, A);

      await sleep(P(200));

      // Speed order (PAR considered), tie coin flip
      const aSpd = effectiveSpeed(A), bSpd = effectiveSpeed(B);
      let order = [{ side:'A', move:state.queuedMove }, { side:'B', move:cpuMove }];
      if(bSpd > aSpd || (bSpd===aSpd && Math.random()<0.5)) order.reverse();

      state.waitingForPlayerChoice=false;
      enableMoveButtons(false);
      $('#btnNext').disabled = true;

      for(const step of order){
        if(!battleAlive()) break;
        const atkSide = (step.side==='A')? 'A':'B';
        const defSide = (step.side==='A')? 'B':'A';
        const atk = (step.side==='A')? currA(): currB();
        const def = (step.side==='A')? currB(): currA();
        if(atk.hp<=0 || def.hp<=0) continue;

        const m = step.move;

        // Pre-move status checks
        setBanner(`${atk.name} is preparing to move…`, step.side==='A'?'your':'rival');
        if(handlePreMoveStatus(atk)){
          log(`${atk.name} is incapacitated by status.`);
          setHPBars();
          await sleep(P(450));
          continue;
        }

        // Announce
        setBanner(`${atk.name} used ${m.display}!`, step.side==='A'?'your':'rival');

        // Pure status move
        if(m.category==='status' && (!m.power || m.power===0)){
          if(Math.random()*100 > (m.accuracy ?? 100)){
            log(`${atk.name}'s ${m.display} missed!`);
            await impactMiss(defSide); await sleep(P(300));
          } else {
            await animateAttack(atkSide, defSide, m);
            const applied = tryApplyStatus(def, m.ailment_code, m.ailment_chance || 100);
            if(applied){
              log(`${def.name} is now ${applied.toUpperCase()}!`);
              setBanner(`${def.name} is ${applied.toUpperCase()}!`, 'info');
              state.stats.statusCounts[applied] = (state.stats.statusCounts[applied]||0)+1;
              updateStatusUI(defSide, def);
            } else {
              log(`But it failed!`);
            }
            await sleep(P(350));
          }
          continue;
        }

        // Damaging move flow
        await animateAttack(atkSide, defSide, m);
        if(Math.random()*100 > (m.accuracy ?? 100)){
          await impactMiss(defSide);
          log(`${atk.name}'s ${m.display} missed!`);
          setBanner(`${atk.name}'s ${m.display} missed!`, 'info');
          await sleep(P(300));
          continue;
        }

        // Damage
        let dmg = computeDamage(atk, def, m);
        const crit = Math.random() < 0.1;
        if(crit){ dmg = Math.floor(dmg*1.75); log('Critical hit!'); await screenShake(); }
        def.hp = Math.max(0, def.hp - dmg);
        if(step.side==='A') state.stats.dmgA += dmg; else state.stats.dmgB += dmg;

        await impactHit(defSide, m.type);
        setHPBars();
        log(`${atk.name} dealt ${dmg} damage to ${def.name}.`);
        await sleep(P(320));

        // Secondary status chance
        if(def.hp>0 && m.ailment_code){
          const applied = tryApplyStatus(def, m.ailment_code, m.ailment_chance || 0);
          if(applied){
            log(`${def.name} is now ${applied.toUpperCase()}!`);
            state.stats.statusCounts[applied] = (state.stats.statusCounts[applied]||0)+1;
            setBanner(`${def.name} is ${applied.toUpperCase()}!`, 'info');
            setHPBars(); await sleep(P(240));
          }
        }

        // Faint handling
        if(def.hp<=0){
          log(`${def.name} fainted!`);
          if(step.side==='A') state.stats.koA++; else state.stats.koB++;
          await faintSprite(defSide);
          await sleep(P(250));
          if(step.side==='A'){
            const next = state.rosterB.findIndex((x,i)=> i>state.bIdx && x.hp>0);
            if(next!==-1) state.bIdx=next;
          } else {
            const next = state.rosterA.findIndex((x,i)=> i>state.aIdx && x.hp>0);
            if(next!==-1) state.aIdx=next;
          }
          if(!battleAlive()) break;
          setActiveDisplays();
          setBanner(`${(step.side==='A'?currB():currA()).name} was sent out!`, 'info');
          await sleep(P(350));
        }

        await sleep(P(240));
      }

      // End-of-turn residuals
      if(battleAlive()){
        endOfTurnResidual(currA());
        endOfTurnResidual(currB());
        setHPBars();
      }

      // Win check
      if(!battleAlive()){
        const youWin = state.rosterA.some(m=>m.hp>0);
        await screenShake();
        setBanner(youWin? '🏆 You win!' : '🏆 Rival wins!', youWin?'your':'rival');
        state.stats.rounds = state.round;
        showResult(youWin);
        state.lock=false; return;
      }

      state.round++; setActiveDisplays();
      state.queuedMove=null; state.waitingForPlayerChoice=true;
      $('#btnNext').disabled = false;
      setBanner(`Your turn — choose a move for ${currA().name}.`, 'your');
      enableMoveButtons(true);
      state.lock=false;
      if(state.autoPlay) autoLoop();
    }

    function estimateDamage(attacker, defender, move){
      const A = (move.category==='physical')? attacker.stats.atk : attacker.stats.spa;
      const D = (move.category==='physical')? defender.stats.def : defender.stats.spd;
      let aEff = A;
      if(move.category==='physical' && attacker.status?.type==='brn'){ aEff = Math.floor(aEff * 0.5); }
      let base = (((2*50/5 + 2) * (move.power||0) * (aEff/Math.max(1,D))) / 50) + 2; // FIXED: move.power (not m.power)
      const stab = attacker.types.includes(move.type)? 1.5 : 1.0;
      const eff = effMultiplier(move.type, defender.types);
      const dmg = base * stab * eff * 0.925;
      const roll = (Math.random()*0.15)+0.85;
      return Math.max(1, Math.floor(dmg * roll));
    }
    function computeDamage(attacker, defender, move){ return estimateDamage(attacker, defender, move); }

    /* ======= Status system ======= */
    function handlePreMoveStatus(mon){
      if(mon.status?.type==='slp'){
        mon.status.turns = (mon.status.turns ?? 1);
        if(mon.status.turns>0){ mon.status.turns--; log(`${mon.name} is fast asleep…`); setBanner(`${mon.name} is fast asleep…`, 'info'); return true; }
        log(`${mon.name} woke up!`); setBanner(`${mon.name} woke up!`, 'info'); mon.status = null; return false;
      }
      if(mon.status?.type==='frz'){
        if(Math.random() < 0.2){ log(`${mon.name} thawed out!`); setBanner(`${mon.name} thawed out!`, 'info'); mon.status=null; return false; }
        log(`${mon.name} is frozen solid!`); setBanner(`${mon.name} is frozen solid!`, 'info'); return true;
      }
      if(mon.status?.type==='par'){
        if(Math.random() < 0.25){ log(`${mon.name} is fully paralyzed!`); setBanner(`${mon.name} is fully paralyzed!`, 'info'); return true; }
      }
      return false;
    }

    function tryApplyStatus(target, code, chancePct){
      if(!code || target.status?.type || target.hp<=0) return null;
      if(Math.random()*100 > chancePct) return null;
      switch(code){
        case 'slp': target.status = {type:'slp', turns: Math.floor(Math.random()*3)+1}; break;
        case 'frz': target.status = {type:'frz'}; break;
        case 'par': target.status = {type:'par'}; break;
        case 'brn': target.status = {type:'brn'}; break;
        case 'psn': target.status = {type:'psn'}; break;
        default: return null;
      }
      return code;
    }

    function endOfTurnResidual(mon){
      if(mon.hp<=0) return;
      if(mon.status?.type==='brn' || mon.status?.type==='psn'){
        const dmg = Math.max(1, Math.floor(mon.stats.maxHP / RESIDUAL_FRACTION));
        mon.hp = Math.max(0, mon.hp - dmg);
        log(`${mon.name} is hurt by ${mon.status.type==='brn'?'its burn':'poison'} (${dmg}).`);
        setBanner(`${mon.name} takes damage from ${mon.status.type==='brn'?'burn':'poison'}…`, 'info');
      }
    }

    /* ======= Results Modal ======= */
    function showResult(youWin){
      $('#resultTitle').textContent = youWin ? 'You Win!' : 'Rival Wins!';
      $('#resultSubtitle').textContent = 'Battle Summary';
      $('#rsRounds').textContent = state.stats.rounds;
      $('#rsKO').textContent = `You ${state.stats.koA} — ${state.stats.koB} Rival`;
      $('#rsDmgA').textContent = state.stats.dmgA;
      $('#rsDmgB').textContent = state.stats.dmgB;
      const st = state.stats.statusCounts;
      const mk = (k,l)=>`<span class="px-2 py-1 rounded-full text-slate-200" style="border:1px solid #334155;background:#0f172a">${l}: ${st[k]||0}</span>`;
      $('#rsStatus').innerHTML = mk('par','PAR')+mk('brn','BRN')+mk('psn','PSN')+mk('frz','FRZ')+mk('slp','SLP');
      $('#resultModal').classList.add('show');
    }
    function hideResult(){ $('#resultModal').classList.remove('show'); }

    /* ======= Animations & Effects ======= */
    async function faintSprite(side){
      const img = side==='A' ? $('#spriteA') : $('#spriteB');
      img.classList.add('faint');
      await sleep(P(500));
      img.classList.remove('faint');
    }

    async function animateAttack(attackerSide, defenderSide, move){
      const atkImg = attackerSide==='A' ? $('#spriteA') : $('#spriteB');
      const defImg = defenderSide==='A' ? $('#spriteA') : $('#spriteB');
      const stage = $('#stage');
      const isPhysical = move.category==='physical';

      if(isPhysical){
        atkImg.classList.add(attackerSide==='A' ? 'lunge-right' : 'lunge-left');
        await sleep(P(350));
        atkImg.classList.remove('lunge-right','lunge-left');
      } else {
        const atkRect = atkImg.getBoundingClientRect();
        const defRect = defImg.getBoundingClientRect();
        const stRect = stage.getBoundingClientRect();
        const start = { x:(atkRect.left+atkRect.right)/2 - stRect.left + (attackerSide==='A'?26:-26), y:(atkRect.top+atkRect.bottom)/2 - stRect.top - 8 };
        const end   = { x:(defRect.left+defRect.right)/2 - stRect.left + (defenderSide==='A'?26:-26), y:(defRect.top+defRect.bottom)/2 - stRect.top - 8 };
        const proj = document.createElement('div'); proj.className='proj'; proj.style.background = typeColor(move.type); stage.appendChild(proj);
        const steps=22, dx=(end.x-start.x)/steps, dy=(end.y-start.y)/steps;
        for(let i=0;i<=steps;i++){ const t=i/steps, arc=-30*Math.sin(Math.PI*t); proj.style.left=(start.x+dx*i)+'px'; proj.style.top=(start.y+dy*i+arc)+'px'; await sleep(P(10)); }
        proj.remove();
      }
      await sleep(P(120));
    }

    async function impactHit(defenderSide, type){
      const defImg = defenderSide==='A' ? $('#spriteA') : $('#spriteB');
      const stage = $('#stage');
      defImg.classList.add('flash','shake');
      const r = defImg.getBoundingClientRect(), st = stage.getBoundingClientRect();
      const spark = document.createElement('div'); spark.className='spark';
      spark.style.left = ((r.left+r.right)/2 - st.left) + 'px';
      spark.style.top  = ((r.top+r.bottom)/2 - st.top) + 'px';
      spark.style.background = typeColor(type);
      stage.appendChild(spark);
      await sleep(P(350));
      defImg.classList.remove('flash','shake');
      spark.remove();
      await sleep(P(120));
    }
    async function impactMiss(){ const stage = $('#stage'); stage.classList.add('camshake'); await sleep(P(220)); stage.classList.remove('camshake'); }
    async function screenShake(){ const stage = $('#stage'); stage.classList.add('camshake'); await sleep(P(260)); stage.classList.remove('camshake'); }

    /* ======= Log & Toast ======= */
    function log(t){ const li=document.createElement('li'); li.textContent=t; $('#log').appendChild(li); $('#log').scrollTop=$('#log').scrollHeight; }
    function clearLog(){ $('#log').innerHTML=''; }
    let toastTimer; function toast(msg){ clearTimeout(toastTimer); let t=$('#toast'); if(!t){ t=document.createElement('div'); t.id='toast'; t.className='fixed bottom-3 inset-x-0 mx-auto w-fit max-w-[90%] px-4 py-2 rounded-xl bg-slate-800 text-slate-100 border border-slate-700 text-sm shadow-lg'; document.body.appendChild(t); } t.textContent=msg; t.style.opacity='1'; toastTimer=setTimeout(()=>t.style.opacity='0',1800); }
  </script>
</body>
</html>