<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Pocket Stadium — Kanto 3v3 (Gen‑1 Layout + Status)</title>

  <!-- Tailwind Play CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { ui: ['ui-sans-serif', 'system-ui', 'Segoe UI', 'Roboto', 'Helvetica', 'Arial'] },
          boxShadow: { soft: '0 6px 30px rgba(0,0,0,.08)' }
        }
      }
    }
  </script>

  <style>
    .pixel { image-rendering: pixelated; image-rendering: crisp-edges; }
    .hpbar-inner { transition: width .35s ease; }
    .card { background: rgba(255,255,255,.8); backdrop-filter: blur(8px); border:1px solid #e5e7eb; border-radius: 1rem; box-shadow: 0 6px 30px rgba(0,0,0,.08); }
    .btn { display:inline-flex; align-items:center; justify-content:center; border-radius: .75rem; padding:.5rem 1rem; font-weight:600; color:#fff; background: linear-gradient(180deg, #22c55e, #16a34a); }
    .btn:active { opacity:.9 }
    .btn-secondary { color:#111827; background: linear-gradient(180deg, #e5e7eb, #d1d5db); }
    .btn-warn { background: linear-gradient(180deg, #f59e0b, #d97706); color:#111827; }
    .btn-ghost { background: transparent; color:#334155; }
    .chip { display:inline-flex; align-items:center; gap:.25rem; border-radius:999px; padding:.25rem .625rem; font-size:.75rem; font-weight:700; background:#f1f5f9; color:#334155; }
    .grid-auto-fit { display:grid; grid-template-columns: repeat(auto-fit, minmax(84px, 1fr)); gap:.75rem; }
    .tap { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
    .type-badge { font-size:10px; font-weight:800; padding:.125rem .5rem; border-radius:999px; color:#fff; }
    .move-btn { width:100%; border-radius:.75rem; padding:.5rem .75rem; font-size:.9rem; font-weight:700; color:#fff; display:flex; align-items:center; justify-content:space-between; }
    .tag { font-size:10px; font-weight:700; padding:.125rem .5rem; border-radius:999px; background:#e5e7eb; color:#334155; }

    /* Bottom-sheet layout + scroll fix */
    .sheet { max-height: 85vh; display: flex; flex-direction: column; }
    .sheet-scroll { flex: 1; min-height: 0; overflow-y: auto; -webkit-overflow-scrolling: touch; }
    body.no-scroll { overflow: hidden; }

    /* ====== Battle Animations ====== */
    @keyframes lunge-right { 0%{transform:translateX(0)} 40%{transform:translateX(22px)} 100%{transform:translateX(0)} }
    @keyframes lunge-left  { 0%{transform:translateX(0)} 40%{transform:translateX(-22px)} 100%{transform:translateX(0)} }
    .lunge-right { animation: lunge-right .35s ease; }
    .lunge-left  { animation: lunge-left  .35s ease; }

    @keyframes shake {
      0%,100%{ transform:translate(0,0) }
      20%{ transform:translate(-4px,0) }
      40%{ transform:translate(4px,0) }
      60%{ transform:translate(-3px,0) }
      80%{ transform:translate(3px,0) }
    }
    .shake { animation: shake .35s ease; }

    @keyframes flash { 0%{filter:brightness(1)} 50%{ filter:brightness(2)} 100%{filter:brightness(1)} }
    .flash { animation: flash .28s ease; }

    @keyframes jiggle {
      0%{transform:translate(0,0)} 25%{transform:translate(0,-2px)} 50%{transform:translate(0,0)} 75%{transform:translate(0,2px)} 100%{transform:translate(0,0)}
    }

    .proj { position:absolute; width:10px; height:10px; border-radius:999px; box-shadow: 0 0 10px rgba(0,0,0,.25); transform: translate(-50%, -50%); pointer-events:none; }
    @keyframes spark { 0% { transform: scale(.6); opacity: 0.9; } 100% { transform: scale(1.6); opacity: 0; } }
    .spark { position:absolute; width:24px; height:24px; border-radius:50%; box-shadow: 0 0 18px rgba(255,255,255,.9), inset 0 0 12px rgba(255,255,255,.9); animation: spark .35s ease forwards; pointer-events:none; }
    .camshake { animation: jiggle .25s ease; }

    /* ====== Gen‑1 battle layout ====== */
    .stage { position:relative; overflow:hidden; }
    .battle { position:relative; height: 300px;
      background: radial-gradient(ellipse at 20% 85%, rgba(0,0,0,.06), transparent 45%),
                  radial-gradient(ellipse at 80% 15%, rgba(0,0,0,.06), transparent 45%);
      border-radius: .75rem; }
    @media (min-width: 640px){ .battle { height: 360px; } }

    /* GB-style HP box */
    .hpbox { min-width: 210px; background:#fff; border:2px solid #111827; border-radius:.5rem; padding:.35rem .5rem .5rem; box-shadow: inset 0 0 0 2px #e5e7eb; }
    .hpbox-title { font-weight:800; font-size:.8rem; letter-spacing:.02em; }
    .hpbox-hp { font-size:.65rem; color:#475569; display:flex; justify-content:space-between; align-items:center; }
    .hpbar { height:8px; width:100%; background:#e5e7eb; border-radius:999px; overflow:hidden; }
    .lv { font-size:.7rem; font-weight:800; color:#111827; }
    .st-dot { width:8px; height:8px; border-radius:999px; border:1px solid #0f172a; }
    .st-tag { font-size:.6rem; font-weight:800; padding:.05rem .3rem; border:1px solid #0f172a; border-radius:.25rem; }

    /* Positions */
    .opp-hp{ position:absolute; top:10px; left:10px; }
    .opp-sprite{ position:absolute; top:56px; right:18px; width:140px; height:140px; }
    .ply-sprite{ position:absolute; bottom:64px; left:18px; width:140px; height:140px; }
    .ply-hp{ position:absolute; bottom:10px; right:10px; }
    @media (min-width:640px){ .opp-sprite{ width:168px; height:168px; top:60px; right:26px; } .ply-sprite{ width:168px; height:168px; bottom:72px; left:26px; } .hpbox{ min-width:230px; } }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-sky-50 via-emerald-50 to-white font-ui text-slate-800">
  <header class="sticky top-0 z-10 bg-white/80 backdrop-blur border-b border-slate-200">
    <div class="max-w-5xl mx-auto px-4 py-3 flex items-center gap-3">
      <img alt="Pokeball" src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/poke-ball.png" class="w-6 h-6 pixel"/>
      <h1 class="text-lg font-bold">Pocket Stadium — Kanto 3v3</h1>
      <span class="ml-auto text-xs text-slate-500">Gen‑1 layout • Lv.50 • TM/HM • Animations • Status</span>
    </div>
  </header>

  <main class="max-w-5xl mx-auto px-4 py-4 space-y-6">
    <!-- Builder -->
    <section id="builder" class="space-y-4">
      <div class="flex items-center justify-between">
        <h2 class="text-xl font-bold">Build your teams</h2>
        <div class="flex gap-2">
          <button id="btnRandomize" class="btn-secondary tap">Randomize teams</button>
          <button id="btnClear" class="btn-ghost tap">Clear</button>
        </div>
      </div>

      <div class="grid md:grid-cols-2 gap-4">
        <div class="card p-4">
          <div class="flex items-center gap-2 mb-3">
            <span class="chip">You</span>
            <div class="text-sm text-slate-500">Choose 3 (tap Moves to pick up to 4)</div>
            <div class="ml-auto"><button id="pickA" class="btn tap">Pick</button></div>
          </div>
          <div id="teamA" class="grid grid-cols-3 gap-3"></div>
        </div>

        <div class="card p-4">
          <div class="flex items-center gap-2 mb-3">
            <span class="chip">Rival</span>
            <div class="text-sm text-slate-500">Choose 3 (you can set their moves too)</div>
            <div class="ml-auto"><button id="pickB" class="btn tap">Pick</button></div>
          </div>
          <div id="teamB" class="grid grid-cols-3 gap-3"></div>
        </div>
      </div>

      <div class="flex flex-wrap items-center gap-3 pt-2">
        <button id="startBattle" class="btn btn-warn tap disabled:opacity-50" disabled>Start Battle</button>
        <div id="buildHint" class="text-sm text-slate-500">Pick 3 for each side to begin.</div>
      </div>
    </section>

    <!-- Arena -->
    <section id="arena" class="hidden space-y-4">
      <div class="flex items-center gap-3">
        <h2 class="text-xl font-bold">Battle</h2>
        <span id="roundTag" class="chip">Round 1</span>
        <div class="ml-auto flex items-center gap-3">
          <label class="flex items-center gap-2 text-sm">
            Pace
            <select id="pace" class="border rounded-lg px-2 py-1">
              <option value="1.2">Slow</option>
              <option value="1.0" selected>Normal</option>
              <option value="0.8">Fast</option>
            </select>
          </label>
          <label class="flex items-center gap-2 text-sm">
            <input id="autoPlay" type="checkbox" class="accent-emerald-600"> Auto play
          </label>
          <button id="reset" class="btn-secondary tap">Back to builder</button>
        </div>
      </div>

      <!-- Rosters -->
      <div class="grid md:grid-cols-2 gap-4">
        <div class="card p-3">
          <div class="flex items-center gap-2 mb-2">
            <span class="chip">You</span><div class="text-xs text-slate-500">Roster</div>
          </div>
          <div id="rosterA" class="flex gap-2"></div>
        </div>
        <div class="card p-3">
          <div class="flex items-center gap-2 mb-2">
            <span class="chip">Rival</span><div class="text-xs text-slate-500">Roster</div>
          </div>
          <div id="rosterB" class="flex gap-2"></div>
        </div>
      </div>

      <!-- Stage (Gen‑1 layout) -->
      <div class="card p-4 stage" id="stage">
        <div class="battle">
          <!-- Opponent HP (top-left) -->
          <div class="hpbox opp-hp">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-2">
                <span id="dotB" class="st-dot"></span>
                <div id="nameB" class="hpbox-title">???</div>
                <span id="stTextB" class="st-tag hidden">OK</span>
              </div>
              <div class="lv">Lv 50</div>
            </div>
            <div class="hpbox-hp"><span>HP <span id="hpTextB"></span></span></div>
            <div class="hpbar mt-1"><div id="hpBarB" class="hpbar-inner h-full" style="width:100%"></div></div>
          </div>

          <!-- Opponent sprite (top-right) -->
          <img id="spriteB" class="pixel opp-sprite" alt="Opponent sprite"/>

          <!-- Player sprite (bottom-left) -->
          <img id="spriteA" class="pixel ply-sprite" alt="Your sprite"/>

          <!-- Player HP (bottom-right) -->
          <div class="hpbox ply-hp">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-2">
                <span id="dotA" class="st-dot"></span>
                <div id="nameA" class="hpbox-title">???</div>
                <span id="stTextA" class="st-tag hidden">OK</span>
              </div>
              <div class="lv">Lv 50</div>
            </div>
            <div class="hpbox-hp"><span>HP <span id="hpTextA"></span></span></div>
            <div class="hpbar mt-1"><div id="hpBarA" class="hpbar-inner h-full" style="width:100%"></div></div>
          </div>
        </div>

        <!-- Move buttons -->
        <div class="mt-4 grid grid-cols-2 gap-2" id="moveButtons"></div>

        <div class="mt-2 flex items-center gap-2">
          <button id="btnNext" class="btn-secondary tap disabled:opacity-50" disabled>Next</button>
        </div>
      </div>

      <!-- Log -->
      <div class="card p-3">
        <div class="flex items-center gap-2 mb-2">
          <span class="chip">Battle log</span>
          <button id="clearLog" class="ml-auto btn-ghost text-sm tap">Clear</button>
        </div>
        <ol id="log" class="space-y-2 text-sm max-h-80 overflow-auto pr-1"></ol>
      </div>
    </section>
  </main>

  <!-- Picker Overlay (Team) -->
  <div id="picker" class="fixed inset-0 z-20 hidden">
    <div class="absolute inset-0 bg-black/40" data-close></div>
    <div class="absolute inset-x-0 bottom-0 sheet rounded-t-3xl bg-white p-4 space-y-3">
      <div class="flex items-center gap-2">
        <div id="pickerLabel" class="chip">Pick — You</div>
        <input id="search" type="text" placeholder="Search Pokémon…" class="ml-auto w-full max-w-xs px-3 py-2 rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-400" />
        <button id="donePick" class="btn-secondary tap">Done</button>
      </div>
      <div id="pickedCount" class="text-xs text-slate-500">0 / 3 selected</div>
      <div class="sheet-scroll pr-1">
        <div id="grid" class="grid-auto-fit"></div>
      </div>
    </div>
  </div>

  <!-- Move Picker Overlay -->
  <div id="movePicker" class="fixed inset-0 z-30 hidden">
    <div class="absolute inset-0 bg-black/40" data-close-mv></div>
    <div class="absolute inset-x-0 bottom-0 sheet rounded-t-3xl bg-white p-4 space-y-3">
      <div class="flex items-center gap-2">
        <div id="mvTitle" class="chip">Moves — ???</div>
        <div class="ml-auto flex items-center gap-2 text-xs">
          <label class="flex items-center gap-1"><input id="fltLvl" type="checkbox" class="accent-emerald-600" checked><span>Level‑Up ≤50</span></label>
          <label class="flex items-center gap-1"><input id="fltTM" type="checkbox" class="accent-emerald-600" checked><span>TM/HM</span></label>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <input id="mvSearch" type="text" placeholder="Search moves…" class="w-full px-3 py-2 rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-400" />
        <button id="mvRecommend" class="btn-secondary tap">Recommend 4</button>
        <button id="mvClear" class="btn-ghost tap">Clear</button>
        <button id="mvDone" class="btn tap">Done</button>
      </div>
      <div id="mvPickedCount" class="text-xs text-slate-500">0 / 4 selected</div>
      <div class="sheet-scroll pr-1">
        <div id="mvList" class="space-y-2"></div>
      </div>
    </div>
  </div>

  <footer class="max-w-5xl mx-auto px-4 py-8 text-center text-xs text-slate-500">
    Data & sprites from <a class="underline" href="https://pokeapi.co/" target="_blank" rel="noreferrer">PokéAPI</a>.
  </footer>

  <script>
    /* ======= Utils & Constants ======= */
    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));
    const sleep = ms => new Promise(r => setTimeout(r, ms));
    const cap = s => s.charAt(0).toUpperCase() + s.slice(1);
    const gridSpriteURL = id => `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`;

    const TYPE_COLORS = {
      normal:'#A8A77A', fire:'#EE8130', water:'#6390F0', electric:'#F7D02C', grass:'#7AC74C',
      ice:'#96D9D6', fighting:'#C22E28', poison:'#A33EA1', ground:'#E2BF65', flying:'#A98FF3',
      psychic:'#F95587', bug:'#A6B91A', rock:'#B6A136', ghost:'#735797', dragon:'#6F35FC'
    };
    const SPECIAL_TYPES = new Set(['fire','water','grass','electric','ice','psychic','dragon']);
    const typeColor = t => TYPE_COLORS[t] || '#64748b';

    // Gen‑1 type chart
    const chart = {
      normal:{ rock:0.5, ghost:0 },
      fire:{ fire:0.5, water:0.5, grass:2, ice:2, bug:2, rock:0.5, dragon:0.5 },
      water:{ fire:2, water:0.5, grass:0.5, ground:2, rock:2, dragon:0.5 },
      electric:{ water:2, electric:0.5, grass:0.5, ground:0, flying:2, dragon:0.5 },
      grass:{ fire:0.5, water:2, grass:0.5, poison:0.5, ground:2, flying:0.5, bug:0.5, rock:2, dragon:0.5 },
      ice:{ water:0.5, ice:0.5, grass:2, ground:2, flying:2, dragon:2 },
      fighting:{ normal:2, ice:2, poison:0.5, flying:0.5, psychic:0.5, bug:0.5, rock:2, ghost:0 },
      poison:{ grass:2, poison:0.5, ground:0.5, rock:0.5, ghost:0.5 },
      ground:{ fire:2, electric:2, grass:0.5, poison:2, flying:0, bug:0.5, rock:2 },
      flying:{ electric:0.5, grass:2, fighting:2, bug:2, rock:0.5 },
      psychic:{ fighting:2, poison:2, psychic:0.5 },
      bug:{ fire:0.5, grass:2, fighting:0.5, poison:2, flying:0.5, psychic:2, ghost:0.5 },
      rock:{ fire:2, ice:2, fighting:0.5, ground:0.5, flying:2, bug:2 },
      ghost:{ normal:0, psychic:0, ghost:2 },
      dragon:{ dragon:2 }
    };
    function effMultiplier(moveType, targetTypes){ let mult = 1; for(const t of targetTypes){ mult *= (chart[moveType]?.[t] ?? 1); } return mult; }
    function categoryFromType(t){ return SPECIAL_TYPES.has(t) ? 'special' : 'physical'; }

    // Pace multiplier (bigger = slower)
    function P(ms){ const m = Number($('#pace')?.value || 1.0); return Math.round(ms * m); }

    // Status constants
    const PAR_SPEED = 0.5;      // paralysis speed modifier
    const BRN_PHYS  = 0.5;      // burn physical damage modifier
    const THAW_CHANCE = 0.2;    // 20% to thaw each turn
    const RESIDUAL_FRACTION = 16; // 1/16 max HP

    const AIL_MAP = {
      paralysis:'par', burn:'brn', poison:'psn', 'bad-poison':'psn', freeze:'frz', sleep:'slp',
      confusion:'cnf' // optional, not fully simulated
    };

    /* ======= App State ======= */
    const state = {
      allPokemon: [],
      teamA: [], teamB: [],
      pickingFor: 'A', tempPick: new Set(),
      // Move editor
      mvContext: null,
      mvTemp: new Set(),
      mvPoolCache: new Map(),
      moveCache: new Map(),
      typesById: new Map(),
      // Battle
      rosterA: [], rosterB: [], aIdx:0, bIdx:0, round:1,
      waitingForPlayerChoice:true, queuedMove:null, autoPlay:false, lock:false
    };

    /* ======= Boot ======= */
    document.addEventListener('DOMContentLoaded', async () => {
      renderTeams(); wireBuilder(); wireArena();
      await loadKanto();
    });

    async function loadKanto(){
      try {
        const res = await fetch('https://pokeapi.co/api/v2/pokemon?limit=151');
        const data = await res.json();
        state.allPokemon = data.results.map((p,i)=>({id:i+1, name:cap(p.name)}));
        renderGrid();
      } catch (e) { toast('Could not load Kanto list. Try again.'); console.error(e); }
    }

    /* ======= Builder ======= */
    function wireBuilder(){
      $('#pickA').addEventListener('click', ()=>openPicker('A'));
      $('#pickB').addEventListener('click', ()=>openPicker('B'));
      $('#btnClear').addEventListener('click', ()=>{ state.teamA=[]; state.teamB=[]; renderTeams(); updateStartButton(); });
      $('#btnRandomize').addEventListener('click', ()=>{
        const ids = Array.from({length:151},(_,i)=>i+1); shuffle(ids);
        state.teamA = ids.slice(0,3).map(id=>({id,name:nameFor(id)}));
        state.teamB = ids.slice(3,6).map(id=>({id,name:nameFor(id)}));
        renderTeams(); updateStartButton();
      });
      $('#startBattle').addEventListener('click', startBattle);
    }

    function nameFor(id){ const p=state.allPokemon.find(x=>x.id===id); return p?p.name:`#${id}`; }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

    function renderTeams(){
      const moveChips = (p) => {
        const list = p.moves?.slice(0,4) || [];
        if(!list.length) return '<span class="text-[10px] text-slate-500">No moves chosen</span>';
        return list.map(n=>`<span class="tag">${cleanMoveName(n)}</span>`).join(' ');
      };
      const slot = (teamKey, p, idx) => `
        <div class="card p-2 flex flex-col items-center">
          <img src="${gridSpriteURL(p.id)}" alt="${p.name}" class="w-16 h-16 pixel"/>
          <div class="text-xs mt-1 text-center">${p.name}</div>
          <div class="mt-2 flex items-center gap-2">
            <button class="btn-ghost text-xs tap" data-mv>Edit Moves</button>
            <button class="btn-ghost text-xs tap text-rose-600" data-remove>Remove</button>
          </div>
          <div class="mt-2 flex flex-wrap gap-1 justify-center">${moveChips(p)}</div>
        </div>`;
      const filler = `<div class="rounded-2xl border border-dashed border-slate-300 h-24 flex items-center justify-center text-slate-400 text-xs">Empty</div>`;

      const mount=(el, teamKey)=>{
        el.innerHTML='';
        const team = state[teamKey];
        team.forEach((p, idx)=>{
          const wrap=document.createElement('div'); wrap.innerHTML=slot(teamKey,p,idx);
          wrap.querySelector('[data-remove]').addEventListener('click', ()=>{ team.splice(idx,1); renderTeams(); updateStartButton(); });
          wrap.querySelector('[data-mv]').addEventListener('click', ()=> openMovePicker(teamKey, p.id, p.name));
          el.appendChild(wrap.firstElementChild);
        });
        for(let i=team.length;i<3;i++){ const d=document.createElement('div'); d.innerHTML=filler; el.appendChild(d.firstElementChild); }
      };
      mount($('#teamA'), 'teamA'); mount($('#teamB'), 'teamB');
      updateStartButton();
    }

    function updateStartButton(){
      const ok=state.teamA.length===3 && state.teamB.length===3;
      $('#startBattle').disabled=!ok;
      $('#buildHint').textContent = ok ? 'Optionally edit moves, then Start Battle.' : 'Pick 3 for each side to begin.';
    }

    /* ======= Team Picker ======= */
    function openPicker(team){
      state.pickingFor=team;
      state.tempPick = new Set((team==='A'?state.teamA:state.teamB).map(p=>p.id));
      $('#pickerLabel').textContent=`Pick — ${team==='A'?'You':'Rival'}`;
      $('#pickedCount').textContent=`${state.tempPick.size} / 3 selected`;
      document.body.classList.add('no-scroll');
      $('#picker').classList.remove('hidden');
      $('#search').value=''; filterGrid('');
    }
    function closePicker(commit=false){
      if(commit){
        const list = Array.from(state.tempPick).slice(0,3).map(id=>{
          const existing = (state.pickingFor==='A'?state.teamA:state.teamB).find(x=>x.id===id);
          return existing ? existing : ({id, name:nameFor(id)});
        });
        if(state.pickingFor==='A') state.teamA=list; else state.teamB=list;
        renderTeams(); updateStartButton();
      }
      $('#picker').classList.add('hidden');
      document.body.classList.remove('no-scroll');
    }
    $('#donePick').addEventListener('click', ()=>closePicker(true));
    $('#picker').addEventListener('click', (e)=>{ if(e.target.hasAttribute('data-close')) closePicker(false); });
    $('#search').addEventListener('input', (e)=>filterGrid(e.target.value.trim().toLowerCase()));

    function renderGrid(){
      const grid=$('#grid'); grid.innerHTML='';
      state.allPokemon.forEach(p=>{
        const card=document.createElement('button');
        card.className='tap rounded-2xl border border-slate-200 p-2 flex flex-col items-center hover:border-emerald-400 focus:outline-none';
        card.setAttribute('data-id', p.id);
        card.innerHTML=`<img src="${gridSpriteURL(p.id)}" alt="${p.name}" class="w-14 h-14 pixel"/><div class="text-xs mt-1">${p.name}</div>`;
        card.addEventListener('click', ()=>toggleTempPick(p.id, card));
        grid.appendChild(card);
      });
    }
    function filterGrid(q){
      $$('#grid [data-id]').forEach(el=>{
        const id=Number(el.getAttribute('data-id'));
        const name=nameFor(id).toLowerCase();
        const match=!q || name.includes(q) || String(id).padStart(3,'0').includes(q);
        el.classList.toggle('hidden', !match);
        reflectPickedUI(id, el);
      });
    }
    function toggleTempPick(id, el){
      if(state.tempPick.has(id)) state.tempPick.delete(id);
      else { if(state.tempPick.size>=3) return; state.tempPick.add(id); }
      $('#pickedCount').textContent=`${state.tempPick.size} / 3 selected`;
      reflectPickedUI(id, el);
    }
    function reflectPickedUI(id, el){ const picked=state.tempPick.has(id); el.style.borderColor=picked?'#10b981':'#e5e7eb'; el.style.boxShadow=picked?'0 0 0 3px rgba(16,185,129,.2)':'none'; }

    /* ======= Move Picker ======= */
    async function openMovePicker(team, id, name){
      $('#mvTitle').textContent = `Moves — ${name} (${team==='A'?'You':'Rival'})`;
      $('#mvPickedCount').textContent = `0 / 4 selected`;
      $('#mvSearch').value=''; $('#fltLvl').checked = true; $('#fltTM').checked = true;
      state.mvContext = {team, id, name, types: null};
      document.body.classList.add('no-scroll');
      $('#movePicker').classList.remove('hidden');

      const pool = await getMovePool(id);
      const types = state.typesById.get(id) || [];
      state.mvContext.types = types;

      const teamArr = state[team === 'A' ? 'teamA' : 'teamB'];
      const entry = teamArr.find(x=>x.id===id);
      state.mvTemp = new Set((entry?.moves || []).slice(0,4));

      renderMoveList();
    }
    function closeMovePicker(commit=false){
      if(commit){
        const teamArr = state[state.mvContext.team === 'A' ? 'teamA' : 'teamB'];
        const entry = teamArr.find(x=>x.id===state.mvContext.id);
        if(entry) entry.moves = Array.from(state.mvTemp).slice(0,4);
        renderTeams();
      }
      $('#movePicker').classList.add('hidden');
      document.body.classList.remove('no-scroll');
      state.mvContext = null; state.mvTemp = new Set();
    }
    document.addEventListener('click', (e)=>{
      if(e.target.hasAttribute?.('data-close-mv')) closeMovePicker(false);
    });
    $('#mvDone').addEventListener('click', ()=>closeMovePicker(true));
    $('#mvClear').addEventListener('click', ()=>{ state.mvTemp.clear(); renderMoveList(); });
    $('#mvRecommend').addEventListener('click', ()=>{
      const pool = getFilteredMovePool();
      const picks = recommendMoves(pool, state.mvContext.types).slice(0,4).map(m=>m.key);
      state.mvTemp = new Set(picks);
      renderMoveList();
    });
    $('#mvSearch').addEventListener('input', renderMoveList);
    $('#fltLvl').addEventListener('change', renderMoveList);
    $('#fltTM').addEventListener('change', renderMoveList);

    function renderMoveList(){
      const list = $('#mvList'); list.innerHTML='';
      const q = $('#mvSearch').value.trim().toLowerCase();
      const filtered = getFilteredMovePool().filter(m=>{
        return !q || m.display.toLowerCase().includes(q) || m.type.includes(q);
      });

      filtered.sort((a,b)=>{
        const stabA = state.mvContext.types?.includes(a.type) ? 1 : 0;
        const stabB = state.mvContext.types?.includes(b.type) ? 1 : 0;
        // Prefer STAB ≥ power ≥ level/TM; status moves sprinkled in
        const catA = a.category==='status'? -1 : 1;
        const catB = b.category==='status'? -1 : 1;
        return (stabB-stabA) || (catB-catA) || (b.power - (a.power||0)) || ((b.level||0) - (a.level||0)) || (a.method==='machine'?1:-1);
      });

      for(const m of filtered){
        const row = document.createElement('button');
        const picked = state.mvTemp.has(m.key);
        row.className = 'w-full border rounded-xl p-2 flex items-center gap-3 tap';
        row.style.borderColor = picked ? '#10b981' : '#e5e7eb';
        row.style.boxShadow = picked ? '0 0 0 3px rgba(16,185,129,.15)' : 'none';
        const ail = m.ailment_code ? ` • ${m.ailment_code.toUpperCase()}${m.ailment_chance?(' '+m.ailment_chance+'%'):''}` : '';
        row.innerHTML = `
          <span class="type-badge" style="background:${typeColor(m.type)}">${m.type.toUpperCase()}</span>
          <div class="flex-1 text-left">
            <div class="font-bold">${m.display}</div>
            <div class="text-[11px] text-slate-600">
              ${m.category==='status' ? 'Status' : ('Pow ' + (m.power ?? '—'))}
              • Acc ${m.accuracy ?? '—'}%
              • ${cap(m.category)}${ail}
              • ${m.method==='machine' ? 'TM/HM' : ('Lv ' + (m.level||'?'))}
              ${m.sources?.length? '• ' + m.sources.map(src=>src==='red-blue'?'RB':'Y').join('/') : ''}
            </div>
          </div>
          <div class="text-[11px] px-2 py-1 rounded-md ${picked?'bg-emerald-100 text-emerald-700':'bg-slate-100 text-slate-600'}">${picked?'Selected':'Select'}</div>
        `;
        row.addEventListener('click', ()=>{
          if(picked){ state.mvTemp.delete(m.key); }
          else {
            if(state.mvTemp.size>=4) { toast('Max 4 moves.'); return; }
            state.mvTemp.add(m.key);
          }
          $('#mvPickedCount').textContent = `${state.mvTemp.size} / 4 selected`;
          renderMoveList();
        });
        list.appendChild(row);
      }
      $('#mvPickedCount').textContent = `${state.mvTemp.size} / 4 selected`;
    }
    function getFilteredMovePool(){
      const pool = state.mvPoolCache.get(state.mvContext.id) || [];
      const incLvl = $('#fltLvl').checked, incTM = $('#fltTM').checked;
      return pool.filter(m => (m.method==='level-up' && incLvl) || (m.method==='machine' && incTM));
    }

    async function getMovePool(id){
      if(state.mvPoolCache.has(id)) return state.mvPoolCache.get(id);
      const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
      const p = await res.json();
      const types = p.types.sort((a,b)=>a.slot-b.slot).map(t=>t.type.name);
      state.typesById.set(id, types);
      const pool = await assembleGen1MovePool(p.moves);
      state.mvPoolCache.set(id, pool);
      return pool;
    }

    async function assembleGen1MovePool(movesArray){
      const vgOK = new Set(['red-blue','yellow']);
      const agg = new Map();
      for(const m of movesArray){
        for(const v of m.version_group_details){
          if(!vgOK.has(v.version_group.name)) continue;
          const method = v.move_learn_method.name;
          if(method==='level-up' && v.level_learned_at>50) continue;
          if(method!=='level-up' && method!=='machine') continue;
          const key = m.move.name;
          if(!agg.has(key)) agg.set(key, {name:key, methods:new Set(), level:null, sources:new Set()});
          const rec = agg.get(key);
          rec.methods.add(method);
          rec.sources.add(v.version_group.name);
          if(method==='level-up'){ rec.level = Math.max(rec.level||0, v.level_learned_at||0); }
        }
      }
      const out = [];
      for(const {name, methods, level, sources} of agg.values()){
        if(!state.moveCache.has(name)){
          const r = await fetch(`https://pokeapi.co/api/v2/move/${name}`);
          const mv = await r.json();
          state.moveCache.set(name, mv);
        }
        const mv = state.moveCache.get(name);
        const type = mv.type?.name;
        if(!(type in TYPE_COLORS)) continue;

        const category = mv.damage_class?.name || 'status';
        const power = mv.power ?? null;
        const accuracy = mv.accuracy ?? 100;

        // read ailment
        const ailmentRaw = mv.meta?.ailment?.name || 'none';
        const ailment_chance = mv.meta?.ailment_chance ?? mv.effect_chance ?? 0;
        const ailment_code = AIL_MAP[ailmentRaw] || (ailmentRaw==='none'? null : ailmentRaw);

        if(methods.has('level-up')){
          out.push({ key:name, display:cleanMoveName(name), type, category,
            power, accuracy, method:'level-up', level:level||1, sources:[...sources],
            ailment_code, ailment_chance });
        }
        if(methods.has('machine')){
          out.push({ key:name, display:cleanMoveName(name), type, category,
            power, accuracy, method:'machine', level:null, sources:[...sources],
            ailment_code, ailment_chance });
        }
      }
      return out;
    }

    function cleanMoveName(n){ return n.replace(/-/g,' ').replace(/\b\w/g,c=>c.toUpperCase()); }

    function recommendMoves(pool, attackerTypes=[]){
      // Lightly encourage 1 utility/status move
      const scored = pool.map(m=>{
        const stab = attackerTypes.includes(m.type) ? 1.5 : 1.0;
        const base = m.category==='status' ? 40 + (m.ailment_code?20:0) : (m.power||0) * stab;
        const score = base + ((m.level||0)/5) + (m.method==='level-up'? 1 : 0);
        return {score, m};
      });
      scored.sort((a,b)=> b.score - a.score);
      const seen=new Set(), picks=[];
      for(const s of scored){ if(!seen.has(s.m.key)){ seen.add(s.m.key); picks.push(s.m); } if(picks.length>=4) break; }
      if(!picks.length){ picks.push({key:'tackle', display:'Tackle', type:'normal', category:'physical', power:40, accuracy:100, method:'level-up', level:1}); }
      return picks;
    }

    /* ======= Arena ======= */
    function wireArena(){
      $('#reset').addEventListener('click', ()=>{ $('#arena').classList.add('hidden'); $('#builder').classList.remove('hidden'); clearLog(); });
      $('#clearLog').addEventListener('click', clearLog);
      $('#btnNext').addEventListener('click', async ()=>{ if(!state.waitingForPlayerChoice && !state.lock) await resolveTurn(); });
      $('#autoPlay').addEventListener('change', (e)=>{ state.autoPlay=e.target.checked; if(state.autoPlay) autoLoop(); });
    }

    async function startBattle(){
      $('#builder').classList.add('hidden'); $('#arena').classList.remove('hidden'); clearLog();
      state.rosterA=[]; state.rosterB=[]; state.aIdx=0; state.bIdx=0; state.round=1; state.waitingForPlayerChoice=true; state.queuedMove=null; state.lock=false;

      const all6=[...state.teamA, ...state.teamB];
      const details = await Promise.all(all6.map(async (p)=>{
        const mon = await buildMon(p.id);
        if(p.moves && p.moves.length){
          const want = p.moves.slice(0,4);
          const pool = state.mvPoolCache.get(p.id) || await getMovePool(p.id);
          const byKey = new Map(pool.map(x=>[x.key,x]));
          const chosen = [];
          for(const k of want){ if(byKey.has(k)) chosen.push(byKey.get(k)); }
          if(chosen.length){ mon.moves = chosen; }
        }
        return mon;
      }));
      state.rosterA = details.slice(0,3);
      state.rosterB = details.slice(3,6);

      updateRosterBadges(); setActiveDisplays(); renderMoveButtons();
      log(`Battle Start! ${currA().name} vs ${currB().name}.`);
      if(state.autoPlay) autoLoop();
    }

    async function buildMon(id){
      const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
      const p = await res.json();
      const getStat = k => p.stats.find(s=>s.stat.name===k).base_stat;
      const L=50;
      const base = { hp:getStat('hp'), atk:getStat('attack'), def:getStat('defense'), spa:getStat('special-attack'), spd:getStat('special-defense'), spe:getStat('speed') };
      const derived = {
        maxHP: Math.floor(((2*base.hp)*L)/100) + L + 10,
        atk: Math.floor(((2*base.atk)*L)/100) + 5,
        def: Math.floor(((2*base.def)*L)/100) + 5,
        spa: Math.floor(((2*base.spa)*L)/100) + 5,
        spd: Math.floor(((2*base.spd)*L)/100) + 5,
        spe: Math.floor(((2*base.spe)*L)/100) + 5,
      };
      const types = p.types.sort((a,b)=>a.slot-b.slot).map(t=>t.type.name);
      state.typesById.set(id, types);

      const pool = state.mvPoolCache.get(id) || await assembleGen1MovePool(p.moves);
      state.mvPoolCache.set(id, pool);
      const moves = recommendMoves(pool, types).slice(0,4);

      return {
        id, name:cap(p.name), types,
        front:p.sprites.front_default || gridSpriteURL(id),
        back:p.sprites.back_default || p.sprites.front_default || gridSpriteURL(id),
        base, stats:{...derived}, hp:derived.maxHP, moves,
        status:null // {type:'par'|'brn'|'psn'|'frz'|'slp', turns?:number}
      };
    }

    // Helpers
    const currA=()=>state.rosterA[state.aIdx];
    const currB=()=>state.rosterB[state.bIdx];

    function updateRosterBadges(){
      const mk=(mon,isActive)=>`<div title="${mon.name}" class="w-9 h-9 rounded-full border ${isActive?'ring-2 ring-emerald-400':''} border-slate-300 overflow-hidden ${mon.hp>0?'':'grayscale opacity-50'}">
        <img class="w-full h-full pixel" src="${gridSpriteURL(mon.id)}" alt="${mon.name}">
      </div>`;
      $('#rosterA').innerHTML = state.rosterA.map((m,i)=>mk(m,i===state.aIdx)).join('');
      $('#rosterB').innerHTML = state.rosterB.map((m,i)=>mk(m,i===state.bIdx)).join('');
    }

    function setActiveDisplays(){
      const A=currA(), B=currB();
      $('#nameA').textContent=A.name; $('#nameB').textContent=B.name;
      $('#spriteA').src=A.back; $('#spriteB').src=B.front;
      setHPBars(); $('#roundTag').textContent=`Round ${state.round}`;
      updateRosterBadges(); renderMoveButtons();
    }

    function setHPBars(){
      const A=currA(), B=currB();
      const pctA=Math.max(0, Math.round((A.hp/A.stats.maxHP)*100));
      const pctB=Math.max(0, Math.round((B.hp/B.stats.maxHP)*100));
      const colorHP=(el,pct)=>{ if(pct>50){el.style.background='linear-gradient(90deg,#22c55e,#16a34a)';}
        else if(pct>20){el.style.background='linear-gradient(90deg,#f59e0b,#d97706)';}
        else {el.style.background='linear-gradient(90deg,#ef4444,#dc2626)';} };
      $('#hpBarA').style.width=pctA+'%'; colorHP($('#hpBarA'), pctA);
      $('#hpBarB').style.width=pctB+'%'; colorHP($('#hpBarB'), pctB);
      $('#hpTextA').textContent=`${A.hp} / ${A.stats.maxHP}`;
      $('#hpTextB').textContent=`${B.hp} / ${B.stats.maxHP}`;
      updateStatusUI('A', A); updateStatusUI('B', B);
    }

    function updateStatusUI(side, mon){
      const dot = side==='A'? $('#dotA') : $('#dotB');
      const tag = side==='A'? $('#stTextA') : $('#stTextB');
      let color='#10b981'; // OK (green)
      let label=null;
      if(mon.status?.type){
        label = mon.status.type.toUpperCase();
        switch(mon.status.type){
          case 'par': color='#fbbf24'; break;   // amber
          case 'brn': color='#f97316'; break;  // orange
          case 'psn': color='#8b5cf6'; break;  // purple-ish
          case 'frz': color='#22d3ee'; break;  // cyan
          case 'slp': color='#64748b'; break;  // slate
          default: color='#10b981';
        }
      } else {
        const pct = Math.round((mon.hp/mon.stats.maxHP)*100);
        if(pct<=20) color='#ef4444';
        else if(pct<=50) color='#f59e0b';
      }
      dot.style.backgroundColor=color;
      if(label){ tag.textContent=label; tag.classList.remove('hidden'); }
      else { tag.classList.add('hidden'); }
    }

    function renderMoveButtons(){
      const A=currA(); const box=$('#moveButtons'); box.innerHTML='';
      A.moves.forEach((m)=>{
        const btn=document.createElement('button');
        btn.className='move-btn tap';
        btn.style.background = `linear-gradient(180deg, ${typeColor(m.type)}, #333333)`;
        const ail = m.ailment_code ? ` • ${m.ailment_code.toUpperCase()}${m.ailment_chance?(' '+m.ailment_chance+'%'):''}` : '';
        btn.innerHTML = `
          <div class="text-left">
            <div class="font-bold">${m.display}</div>
            <div class="text-[10px] opacity-90">
              ${m.category==='status' ? 'Status' : ('Pow ' + (m.power ?? '—'))}
              • Acc ${m.accuracy ?? '—'}% • ${cap(m.category)}${ail}
            </div>
          </div>
          <span class="type-badge" style="background:${typeColor(m.type)}">${m.type.toUpperCase()}</span>
        `;
        btn.addEventListener('click', async ()=>{
          if(state.lock || !state.waitingForPlayerChoice) return;
          state.queuedMove = m;
          await resolveTurn();
        });
        box.appendChild(btn);
      });
      for(let i=A.moves.length;i<4;i++){
        const d=document.createElement('div');
        d.className='move-btn opacity-60 bg-slate-300 cursor-not-allowed';
        d.innerHTML='<div class="text-left"><div class="font-bold">—</div><div class="text-[10px] opacity-90">No move</div></div>';
        box.appendChild(d);
      }
    }

    async function autoLoop(){
      while(state.autoPlay && battleAlive()){
        if(state.waitingForPlayerChoice){
          const A=currA(), B=currB();
          state.queuedMove = bestMoveAgainst(A, B);
        }
        await resolveTurn();
        await sleep(P(650));
      }
    }

    function battleAlive(){
      const aliveA=state.rosterA.some(m=>m.hp>0);
      const aliveB=state.rosterB.some(m=>m.hp>0);
      return aliveA && aliveB;
    }

    function effectiveSpeed(mon){
      let s = mon.stats.spe;
      if(mon.status?.type==='par') s = Math.floor(s * PAR_SPEED);
      return s;
    }

    function bestMoveAgainst(attacker, defender){
      // prefer non-incapacitating if status-only and defender already has status
      let best = attacker.moves[0];
      let bestScore = -1;
      for(const m of attacker.moves){
        let score;
        if(m.category==='status'){
          const willDoAnything = !defender.status?.type && m.ailment_code;
          score = willDoAnything ? 50 + (m.ailment_chance||0) : 10;
        } else {
          score = estimateDamage(attacker, defender, m);
          // sprinkle bonus if it can also status
          if(m.ailment_code) score += (m.ailment_chance||0)/2;
        }
        if(score>bestScore){ bestScore=score; best=m; }
      }
      return best;
    }

    async function resolveTurn(){
      if(state.lock) return; state.lock=true;
      if(state.waitingForPlayerChoice && !state.queuedMove){ toast('Choose a move.'); state.lock=false; return; }

      const A=currA(), B=currB();
      const cpuMove = bestMoveAgainst(B, A);

      await sleep(P(200));

      // Speed order with paralysis considered; coin flip on tie
      const aSpd = effectiveSpeed(A), bSpd = effectiveSpeed(B);
      let order = [{ side:'A', move:state.queuedMove }, { side:'B', move:cpuMove }];
      if(bSpd > aSpd || (bSpd===aSpd && Math.random()<0.5)) order.reverse();

      state.waitingForPlayerChoice=false;
      $('#btnNext').disabled = true;

      for(const step of order){
        if(!battleAlive()) break;
        const atkSide = (step.side==='A')? 'A':'B';
        const defSide = (step.side==='A')? 'B':'A';
        const atk = (step.side==='A')? currA(): currB();
        const def = (step.side==='A')? currB(): currA();
        if(atk.hp<=0 || def.hp<=0) continue;

        const m = step.move;

        // Pre-move status checks (SLP/FRZ/PAR)
        if(handlePreMoveStatus(atk)){
          setHPBars();
          await sleep(P(350));
          continue; // turn lost
        }

        // Accuracy & announce (status moves announce too)
        await announce(`${atk.name} used ${m.display}!`);

        // If pure status move: just attempt to apply
        if(m.category==='status' && (!m.power || m.power===0)){
          if(Math.random()*100 > (m.accuracy ?? 100)){
            log(`${atk.name}'s ${m.display} missed!`);
            await impactMiss(defSide); await sleep(P(250));
          } else {
            await animateAttack(atkSide, defSide, m);
            const applied = tryApplyStatus(def, m.ailment_code, m.ailment_chance || 100);
            if(applied){ log(`${def.name} is now ${applied.toUpperCase()}!`); updateStatusUI(defSide, def); }
            else { log(`But it failed!`); }
            await sleep(P(300));
          }
          continue;
        }

        // Damaging move flow
        await animateAttack(atkSide, defSide, m);
        if(Math.random()*100 > (m.accuracy ?? 100)){
          await impactMiss(defSide);
          log(`${atk.name}'s ${m.display} missed!`);
          await sleep(P(250));
          continue;
        }

        // Damage
        let dmg = computeDamage(atk, def, m);
        const crit = Math.random() < 0.1;
        if(crit){ dmg = Math.floor(dmg*1.75); log('Critical hit!'); await screenShake(); }
        def.hp = Math.max(0, def.hp - dmg);
        await impactHit(defSide, m.type);
        setHPBars();
        log(`It dealt ${dmg} damage.`);
        await sleep(P(300));

        // Secondary status chance
        if(def.hp>0 && m.ailment_code){
          const applied = tryApplyStatus(def, m.ailment_code, m.ailment_chance || 0);
          if(applied){ log(`${def.name} is now ${applied.toUpperCase()}!`); setHPBars(); await sleep(P(200)); }
        }

        if(def.hp<=0){
          log(`${def.name} fainted!`);
          await sleep(P(450));
          if(step.side==='A'){
            const next = state.rosterB.findIndex((x,i)=> i>state.bIdx && x.hp>0);
            if(next!==-1) state.bIdx=next;
          } else {
            const next = state.rosterA.findIndex((x,i)=> i>state.aIdx && x.hp>0);
            if(next!==-1) state.aIdx=next;
          }
          if(!battleAlive()) break;
          setActiveDisplays(); await sleep(P(300));
        }

        await sleep(P(200));
      }

      // End-of-turn residuals
      if(battleAlive()){
        endOfTurnResidual(currA(), 'A');
        endOfTurnResidual(currB(), 'B');
        setHPBars();
      }

      if(!battleAlive()){
        const winner = state.rosterA.some(m=>m.hp>0)? 'You win!':'Rival wins!';
        await screenShake();
        log(`🏆 ${winner}`);
        state.lock=false; return;
      }

      state.round++; setActiveDisplays();
      state.queuedMove=null; state.waitingForPlayerChoice=true;
      $('#btnNext').disabled = false;
      state.lock=false;
      if(state.autoPlay) autoLoop();
    }

    function estimateDamage(attacker, defender, move){
      const A = (move.category==='physical')? attacker.stats.atk : attacker.stats.spa;
      const D = (move.category==='physical')? defender.stats.def : defender.stats.spd;
      let aEff = A;
      if(move.category==='physical' && attacker.status?.type==='brn'){ aEff = Math.floor(aEff * BRN_PHYS); }
      let base = (((2*50/5 + 2) * (move.power||0) * (aEff/Math.max(1,D))) / 50) + 2;
      const stab = attacker.types.includes(move.type)? 1.5 : 1.0;
      const eff = effMultiplier(move.type, defender.types);
      return base * stab * eff * 0.925;
    }
    function computeDamage(attacker, defender, move){
      const base = estimateDamage(attacker, defender, move);
      const roll = (Math.random()*0.15)+0.85;
      return Math.max(1, Math.floor(base * roll));
    }

    /* ======= Status system ======= */
    function handlePreMoveStatus(mon){
      if(mon.status?.type==='slp'){
        mon.status.turns = (mon.status.turns ?? 1);
        if(mon.status.turns>0){ mon.status.turns--; log(`${mon.name} is fast asleep…`); return true; }
        // wake up
        log(`${mon.name} woke up!`); mon.status = null; return false;
      }
      if(mon.status?.type==='frz'){
        if(Math.random() < THAW_CHANCE){ log(`${mon.name} thawed out!`); mon.status=null; return false; }
        log(`${mon.name} is frozen solid!`); return true;
      }
      if(mon.status?.type==='par'){
        if(Math.random() < 0.25){ log(`${mon.name} is fully paralyzed!`); return true; }
      }
      return false;
    }

    function tryApplyStatus(target, code, chancePct){
      if(!code || target.status?.type || target.hp<=0) return null;
      if(Math.random()*100 > chancePct) return null;
      switch(code){
        case 'slp': target.status = {type:'slp', turns: Math.floor(Math.random()*3)+1}; break;
        case 'frz': target.status = {type:'frz'}; break;
        case 'par': target.status = {type:'par'}; break;
        case 'brn': target.status = {type:'brn'}; break;
        case 'psn': target.status = {type:'psn'}; break;
        default: return null;
      }
      return code;
    }

    function endOfTurnResidual(mon, side){
      if(mon.hp<=0) return;
      if(mon.status?.type==='brn' || mon.status?.type==='psn'){
        const dmg = Math.max(1, Math.floor(mon.stats.maxHP / RESIDUAL_FRACTION));
        mon.hp = Math.max(0, mon.hp - dmg);
        log(`${mon.name} is hurt by ${mon.status.type==='brn'?'its burn':'poison'} (${dmg}).`);
      }
    }

    /* ======= Animations & Effects ======= */
    async function announce(text){ log(text); await sleep(P(250)); }

    async function animateAttack(attackerSide, defenderSide, move){
      const atkImg = attackerSide==='A' ? $('#spriteA') : $('#spriteB');
      const defImg = defenderSide==='A' ? $('#spriteA') : $('#spriteB');
      const stage = $('#stage');
      const isPhysical = move.category==='physical';

      if(isPhysical){
        atkImg.classList.add(attackerSide==='A' ? 'lunge-right' : 'lunge-left');
        await sleep(P(350));
        atkImg.classList.remove('lunge-right','lunge-left');
      } else {
        const atkRect = atkImg.getBoundingClientRect();
        const defRect = defImg.getBoundingClientRect();
        const stRect = stage.getBoundingClientRect();
        const start = { x:(atkRect.left+atkRect.right)/2 - stRect.left + (attackerSide==='A'?26:-26), y:(atkRect.top+atkRect.bottom)/2 - stRect.top - 8 };
        const end   = { x:(defRect.left+defRect.right)/2 - stRect.left + (defenderSide==='A'?26:-26), y:(defRect.top+defRect.bottom)/2 - stRect.top - 8 };
        const proj = document.createElement('div'); proj.className='proj'; proj.style.background = typeColor(move.type); stage.appendChild(proj);
        const steps=22, dx=(end.x-start.x)/steps, dy=(end.y-start.y)/steps;
        for(let i=0;i<=steps;i++){ const t=i/steps, arc=-30*Math.sin(Math.PI*t); proj.style.left=(start.x+dx*i)+'px'; proj.style.top=(start.y+dy*i+arc)+'px'; await sleep(P(10)); }
        proj.remove();
      }
      await sleep(P(120));
    }

    async function impactHit(defenderSide, type){
      const defImg = defenderSide==='A' ? $('#spriteA') : $('#spriteB');
      const stage = $('#stage');
      defImg.classList.add('flash','shake');
      const r = defImg.getBoundingClientRect(), st = stage.getBoundingClientRect();
      const spark = document.createElement('div'); spark.className='spark';
      spark.style.left = ((r.left+r.right)/2 - st.left) + 'px';
      spark.style.top  = ((r.top+r.bottom)/2 - st.top) + 'px';
      spark.style.background = typeColor(type);
      stage.appendChild(spark);
      await sleep(P(350));
      defImg.classList.remove('flash','shake');
      spark.remove();
      await sleep(P(120));
    }
    async function impactMiss(){ const stage = $('#stage'); stage.classList.add('camshake'); await sleep(P(220)); stage.classList.remove('camshake'); }
    async function screenShake(){ const stage = $('#stage'); stage.classList.add('camshake'); await sleep(P(260)); stage.classList.remove('camshake'); }

    /* ======= Log & Toast ======= */
    function log(t){ const li=document.createElement('li'); li.textContent=t; $('#log').appendChild(li); $('#log').scrollTop=$('#log').scrollHeight; }
    function clearLog(){ $('#log').innerHTML=''; }
    let toastTimer; function toast(msg){ clearTimeout(toastTimer); let t=$('#toast'); if(!t){ t=document.createElement('div'); t.id='toast'; t.className='fixed bottom-3 inset-x-0 mx-auto w-fit max-w-[90%] px-4 py-2 rounded-xl bg-slate-900 text-white text-sm shadow-lg'; document.body.appendChild(t); } t.textContent=msg; t.style.opacity='1'; toastTimer=setTimeout(()=>t.style.opacity='0',1600); }
  </script>
</body>
</html>